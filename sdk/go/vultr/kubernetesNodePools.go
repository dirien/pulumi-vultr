// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vultr

import (
	"context"
	"reflect"

	"errors"
	"github.com/dirien/pulumi-vultr/sdk/v2/go/vultr/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Deploy additional node pools to an existing Vultr Kubernetes Engine (VKE) cluster.
//
// ## Example Usage
//
// Create a new VKE cluster:
//
// ```go
// package main
//
// import (
//
//	"github.com/dirien/pulumi-vultr/sdk/v2/go/vultr"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := vultr.NewKubernetesNodePools(ctx, "np-1", &vultr.KubernetesNodePoolsArgs{
//				ClusterId:    pulumi.Any(vultr_kubernetes.K8.Id),
//				NodeQuantity: pulumi.Int(1),
//				Plan:         pulumi.String("vc2-4c-8gb"),
//				Label:        pulumi.String("my-label"),
//				Tag:          pulumi.String("my-tag"),
//				AutoScaler:   pulumi.Bool(true),
//				MinNodes:     pulumi.Int(1),
//				MaxNodes:     pulumi.Int(2),
//				Labels: pulumi.StringMap{
//					"my-label":        pulumi.String("a-label-on-all-nodes"),
//					"my-second-label": pulumi.String("another-label-on-all-nodes"),
//				},
//				Taints: vultr.KubernetesNodePoolsTaintArray{
//					&vultr.KubernetesNodePoolsTaintArgs{
//						Key:    pulumi.String("a-taint"),
//						Value:  pulumi.String("is-tainted"),
//						Effect: pulumi.String("NoExecute"),
//					},
//					&vultr.KubernetesNodePoolsTaintArgs{
//						Key:    pulumi.String("another-taint"),
//						Value:  pulumi.String("is-tainted"),
//						Effect: pulumi.String("NoSchedule"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # Node pool resources are able to be imported into terraform state like other
//
// resources, however, since they rely on a kubernetes cluster, the import state
//
// requires the UUID of the cluster as well. With that in mind, format the second
//
// argument to the `pulumi import` command as a space delimited string of
//
// UUIDs, the first is the cluster ID, the second is the node pool ID. It will
//
// look like this:
//
// "clusterID nodePoolID"
//
// ```sh
// $ pulumi import vultr:index/kubernetesNodePools:KubernetesNodePools my-k8s-np "7365a98b-5a43-450f-bd27-d768827100e5 ec330340-4f50-4526-858f-a39199f568ac"
// ```
type KubernetesNodePools struct {
	pulumi.CustomResourceState

	// Enable the auto scaler for the default node pool.
	AutoScaler pulumi.BoolPtrOutput `pulumi:"autoScaler"`
	// The VKE cluster ID you want to attach this nodepool to.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// Date node was created.
	DateCreated pulumi.StringOutput `pulumi:"dateCreated"`
	// Date of node pool updates.
	DateUpdated pulumi.StringOutput `pulumi:"dateUpdated"`
	// The label to be used as a prefix for nodes in this node pool.
	Label pulumi.StringOutput `pulumi:"label"`
	// A map of key/value pairs for Kubernetes node labels.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The maximum number of nodes to use with the auto scaler.
	MaxNodes pulumi.IntPtrOutput `pulumi:"maxNodes"`
	// The minimum number of nodes to use with the auto scaler.
	MinNodes pulumi.IntPtrOutput `pulumi:"minNodes"`
	// The number of nodes in this node pool.
	NodeQuantity pulumi.IntOutput `pulumi:"nodeQuantity"`
	// Array that contains information about nodes within this node pool.
	Nodes KubernetesNodePoolsNodeArrayOutput `pulumi:"nodes"`
	// The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
	Plan pulumi.StringOutput `pulumi:"plan"`
	// Status of node.
	Status pulumi.StringOutput `pulumi:"status"`
	// A tag that is assigned to this node pool.
	Tag pulumi.StringPtrOutput `pulumi:"tag"`
	// Taints to apply to the nodes in the node pool. Should contain `key`, `value` and `effect`.  The `effect` should be one of `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
	Taints KubernetesNodePoolsTaintArrayOutput `pulumi:"taints"`
}

// NewKubernetesNodePools registers a new resource with the given unique name, arguments, and options.
func NewKubernetesNodePools(ctx *pulumi.Context,
	name string, args *KubernetesNodePoolsArgs, opts ...pulumi.ResourceOption) (*KubernetesNodePools, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.Label == nil {
		return nil, errors.New("invalid value for required argument 'Label'")
	}
	if args.NodeQuantity == nil {
		return nil, errors.New("invalid value for required argument 'NodeQuantity'")
	}
	if args.Plan == nil {
		return nil, errors.New("invalid value for required argument 'Plan'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KubernetesNodePools
	err := ctx.RegisterResource("vultr:index/kubernetesNodePools:KubernetesNodePools", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKubernetesNodePools gets an existing KubernetesNodePools resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKubernetesNodePools(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KubernetesNodePoolsState, opts ...pulumi.ResourceOption) (*KubernetesNodePools, error) {
	var resource KubernetesNodePools
	err := ctx.ReadResource("vultr:index/kubernetesNodePools:KubernetesNodePools", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KubernetesNodePools resources.
type kubernetesNodePoolsState struct {
	// Enable the auto scaler for the default node pool.
	AutoScaler *bool `pulumi:"autoScaler"`
	// The VKE cluster ID you want to attach this nodepool to.
	ClusterId *string `pulumi:"clusterId"`
	// Date node was created.
	DateCreated *string `pulumi:"dateCreated"`
	// Date of node pool updates.
	DateUpdated *string `pulumi:"dateUpdated"`
	// The label to be used as a prefix for nodes in this node pool.
	Label *string `pulumi:"label"`
	// A map of key/value pairs for Kubernetes node labels.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of nodes to use with the auto scaler.
	MaxNodes *int `pulumi:"maxNodes"`
	// The minimum number of nodes to use with the auto scaler.
	MinNodes *int `pulumi:"minNodes"`
	// The number of nodes in this node pool.
	NodeQuantity *int `pulumi:"nodeQuantity"`
	// Array that contains information about nodes within this node pool.
	Nodes []KubernetesNodePoolsNode `pulumi:"nodes"`
	// The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
	Plan *string `pulumi:"plan"`
	// Status of node.
	Status *string `pulumi:"status"`
	// A tag that is assigned to this node pool.
	Tag *string `pulumi:"tag"`
	// Taints to apply to the nodes in the node pool. Should contain `key`, `value` and `effect`.  The `effect` should be one of `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
	Taints []KubernetesNodePoolsTaint `pulumi:"taints"`
}

type KubernetesNodePoolsState struct {
	// Enable the auto scaler for the default node pool.
	AutoScaler pulumi.BoolPtrInput
	// The VKE cluster ID you want to attach this nodepool to.
	ClusterId pulumi.StringPtrInput
	// Date node was created.
	DateCreated pulumi.StringPtrInput
	// Date of node pool updates.
	DateUpdated pulumi.StringPtrInput
	// The label to be used as a prefix for nodes in this node pool.
	Label pulumi.StringPtrInput
	// A map of key/value pairs for Kubernetes node labels.
	Labels pulumi.StringMapInput
	// The maximum number of nodes to use with the auto scaler.
	MaxNodes pulumi.IntPtrInput
	// The minimum number of nodes to use with the auto scaler.
	MinNodes pulumi.IntPtrInput
	// The number of nodes in this node pool.
	NodeQuantity pulumi.IntPtrInput
	// Array that contains information about nodes within this node pool.
	Nodes KubernetesNodePoolsNodeArrayInput
	// The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
	Plan pulumi.StringPtrInput
	// Status of node.
	Status pulumi.StringPtrInput
	// A tag that is assigned to this node pool.
	Tag pulumi.StringPtrInput
	// Taints to apply to the nodes in the node pool. Should contain `key`, `value` and `effect`.  The `effect` should be one of `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
	Taints KubernetesNodePoolsTaintArrayInput
}

func (KubernetesNodePoolsState) ElementType() reflect.Type {
	return reflect.TypeOf((*kubernetesNodePoolsState)(nil)).Elem()
}

type kubernetesNodePoolsArgs struct {
	// Enable the auto scaler for the default node pool.
	AutoScaler *bool `pulumi:"autoScaler"`
	// The VKE cluster ID you want to attach this nodepool to.
	ClusterId string `pulumi:"clusterId"`
	// The label to be used as a prefix for nodes in this node pool.
	Label string `pulumi:"label"`
	// A map of key/value pairs for Kubernetes node labels.
	Labels map[string]string `pulumi:"labels"`
	// The maximum number of nodes to use with the auto scaler.
	MaxNodes *int `pulumi:"maxNodes"`
	// The minimum number of nodes to use with the auto scaler.
	MinNodes *int `pulumi:"minNodes"`
	// The number of nodes in this node pool.
	NodeQuantity int `pulumi:"nodeQuantity"`
	// The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
	Plan string `pulumi:"plan"`
	// A tag that is assigned to this node pool.
	Tag *string `pulumi:"tag"`
	// Taints to apply to the nodes in the node pool. Should contain `key`, `value` and `effect`.  The `effect` should be one of `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
	Taints []KubernetesNodePoolsTaint `pulumi:"taints"`
}

// The set of arguments for constructing a KubernetesNodePools resource.
type KubernetesNodePoolsArgs struct {
	// Enable the auto scaler for the default node pool.
	AutoScaler pulumi.BoolPtrInput
	// The VKE cluster ID you want to attach this nodepool to.
	ClusterId pulumi.StringInput
	// The label to be used as a prefix for nodes in this node pool.
	Label pulumi.StringInput
	// A map of key/value pairs for Kubernetes node labels.
	Labels pulumi.StringMapInput
	// The maximum number of nodes to use with the auto scaler.
	MaxNodes pulumi.IntPtrInput
	// The minimum number of nodes to use with the auto scaler.
	MinNodes pulumi.IntPtrInput
	// The number of nodes in this node pool.
	NodeQuantity pulumi.IntInput
	// The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
	Plan pulumi.StringInput
	// A tag that is assigned to this node pool.
	Tag pulumi.StringPtrInput
	// Taints to apply to the nodes in the node pool. Should contain `key`, `value` and `effect`.  The `effect` should be one of `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
	Taints KubernetesNodePoolsTaintArrayInput
}

func (KubernetesNodePoolsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kubernetesNodePoolsArgs)(nil)).Elem()
}

type KubernetesNodePoolsInput interface {
	pulumi.Input

	ToKubernetesNodePoolsOutput() KubernetesNodePoolsOutput
	ToKubernetesNodePoolsOutputWithContext(ctx context.Context) KubernetesNodePoolsOutput
}

func (*KubernetesNodePools) ElementType() reflect.Type {
	return reflect.TypeOf((**KubernetesNodePools)(nil)).Elem()
}

func (i *KubernetesNodePools) ToKubernetesNodePoolsOutput() KubernetesNodePoolsOutput {
	return i.ToKubernetesNodePoolsOutputWithContext(context.Background())
}

func (i *KubernetesNodePools) ToKubernetesNodePoolsOutputWithContext(ctx context.Context) KubernetesNodePoolsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesNodePoolsOutput)
}

// KubernetesNodePoolsArrayInput is an input type that accepts KubernetesNodePoolsArray and KubernetesNodePoolsArrayOutput values.
// You can construct a concrete instance of `KubernetesNodePoolsArrayInput` via:
//
//	KubernetesNodePoolsArray{ KubernetesNodePoolsArgs{...} }
type KubernetesNodePoolsArrayInput interface {
	pulumi.Input

	ToKubernetesNodePoolsArrayOutput() KubernetesNodePoolsArrayOutput
	ToKubernetesNodePoolsArrayOutputWithContext(context.Context) KubernetesNodePoolsArrayOutput
}

type KubernetesNodePoolsArray []KubernetesNodePoolsInput

func (KubernetesNodePoolsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KubernetesNodePools)(nil)).Elem()
}

func (i KubernetesNodePoolsArray) ToKubernetesNodePoolsArrayOutput() KubernetesNodePoolsArrayOutput {
	return i.ToKubernetesNodePoolsArrayOutputWithContext(context.Background())
}

func (i KubernetesNodePoolsArray) ToKubernetesNodePoolsArrayOutputWithContext(ctx context.Context) KubernetesNodePoolsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesNodePoolsArrayOutput)
}

// KubernetesNodePoolsMapInput is an input type that accepts KubernetesNodePoolsMap and KubernetesNodePoolsMapOutput values.
// You can construct a concrete instance of `KubernetesNodePoolsMapInput` via:
//
//	KubernetesNodePoolsMap{ "key": KubernetesNodePoolsArgs{...} }
type KubernetesNodePoolsMapInput interface {
	pulumi.Input

	ToKubernetesNodePoolsMapOutput() KubernetesNodePoolsMapOutput
	ToKubernetesNodePoolsMapOutputWithContext(context.Context) KubernetesNodePoolsMapOutput
}

type KubernetesNodePoolsMap map[string]KubernetesNodePoolsInput

func (KubernetesNodePoolsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KubernetesNodePools)(nil)).Elem()
}

func (i KubernetesNodePoolsMap) ToKubernetesNodePoolsMapOutput() KubernetesNodePoolsMapOutput {
	return i.ToKubernetesNodePoolsMapOutputWithContext(context.Background())
}

func (i KubernetesNodePoolsMap) ToKubernetesNodePoolsMapOutputWithContext(ctx context.Context) KubernetesNodePoolsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesNodePoolsMapOutput)
}

type KubernetesNodePoolsOutput struct{ *pulumi.OutputState }

func (KubernetesNodePoolsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubernetesNodePools)(nil)).Elem()
}

func (o KubernetesNodePoolsOutput) ToKubernetesNodePoolsOutput() KubernetesNodePoolsOutput {
	return o
}

func (o KubernetesNodePoolsOutput) ToKubernetesNodePoolsOutputWithContext(ctx context.Context) KubernetesNodePoolsOutput {
	return o
}

// Enable the auto scaler for the default node pool.
func (o KubernetesNodePoolsOutput) AutoScaler() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.BoolPtrOutput { return v.AutoScaler }).(pulumi.BoolPtrOutput)
}

// The VKE cluster ID you want to attach this nodepool to.
func (o KubernetesNodePoolsOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// Date node was created.
func (o KubernetesNodePoolsOutput) DateCreated() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringOutput { return v.DateCreated }).(pulumi.StringOutput)
}

// Date of node pool updates.
func (o KubernetesNodePoolsOutput) DateUpdated() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringOutput { return v.DateUpdated }).(pulumi.StringOutput)
}

// The label to be used as a prefix for nodes in this node pool.
func (o KubernetesNodePoolsOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringOutput { return v.Label }).(pulumi.StringOutput)
}

// A map of key/value pairs for Kubernetes node labels.
func (o KubernetesNodePoolsOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The maximum number of nodes to use with the auto scaler.
func (o KubernetesNodePoolsOutput) MaxNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.IntPtrOutput { return v.MaxNodes }).(pulumi.IntPtrOutput)
}

// The minimum number of nodes to use with the auto scaler.
func (o KubernetesNodePoolsOutput) MinNodes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.IntPtrOutput { return v.MinNodes }).(pulumi.IntPtrOutput)
}

// The number of nodes in this node pool.
func (o KubernetesNodePoolsOutput) NodeQuantity() pulumi.IntOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.IntOutput { return v.NodeQuantity }).(pulumi.IntOutput)
}

// Array that contains information about nodes within this node pool.
func (o KubernetesNodePoolsOutput) Nodes() KubernetesNodePoolsNodeArrayOutput {
	return o.ApplyT(func(v *KubernetesNodePools) KubernetesNodePoolsNodeArrayOutput { return v.Nodes }).(KubernetesNodePoolsNodeArrayOutput)
}

// The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
func (o KubernetesNodePoolsOutput) Plan() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringOutput { return v.Plan }).(pulumi.StringOutput)
}

// Status of node.
func (o KubernetesNodePoolsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// A tag that is assigned to this node pool.
func (o KubernetesNodePoolsOutput) Tag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubernetesNodePools) pulumi.StringPtrOutput { return v.Tag }).(pulumi.StringPtrOutput)
}

// Taints to apply to the nodes in the node pool. Should contain `key`, `value` and `effect`.  The `effect` should be one of `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
func (o KubernetesNodePoolsOutput) Taints() KubernetesNodePoolsTaintArrayOutput {
	return o.ApplyT(func(v *KubernetesNodePools) KubernetesNodePoolsTaintArrayOutput { return v.Taints }).(KubernetesNodePoolsTaintArrayOutput)
}

type KubernetesNodePoolsArrayOutput struct{ *pulumi.OutputState }

func (KubernetesNodePoolsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KubernetesNodePools)(nil)).Elem()
}

func (o KubernetesNodePoolsArrayOutput) ToKubernetesNodePoolsArrayOutput() KubernetesNodePoolsArrayOutput {
	return o
}

func (o KubernetesNodePoolsArrayOutput) ToKubernetesNodePoolsArrayOutputWithContext(ctx context.Context) KubernetesNodePoolsArrayOutput {
	return o
}

func (o KubernetesNodePoolsArrayOutput) Index(i pulumi.IntInput) KubernetesNodePoolsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KubernetesNodePools {
		return vs[0].([]*KubernetesNodePools)[vs[1].(int)]
	}).(KubernetesNodePoolsOutput)
}

type KubernetesNodePoolsMapOutput struct{ *pulumi.OutputState }

func (KubernetesNodePoolsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KubernetesNodePools)(nil)).Elem()
}

func (o KubernetesNodePoolsMapOutput) ToKubernetesNodePoolsMapOutput() KubernetesNodePoolsMapOutput {
	return o
}

func (o KubernetesNodePoolsMapOutput) ToKubernetesNodePoolsMapOutputWithContext(ctx context.Context) KubernetesNodePoolsMapOutput {
	return o
}

func (o KubernetesNodePoolsMapOutput) MapIndex(k pulumi.StringInput) KubernetesNodePoolsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KubernetesNodePools {
		return vs[0].(map[string]*KubernetesNodePools)[vs[1].(string)]
	}).(KubernetesNodePoolsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesNodePoolsInput)(nil)).Elem(), &KubernetesNodePools{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesNodePoolsArrayInput)(nil)).Elem(), KubernetesNodePoolsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesNodePoolsMapInput)(nil)).Elem(), KubernetesNodePoolsMap{})
	pulumi.RegisterOutputType(KubernetesNodePoolsOutput{})
	pulumi.RegisterOutputType(KubernetesNodePoolsArrayOutput{})
	pulumi.RegisterOutputType(KubernetesNodePoolsMapOutput{})
}
