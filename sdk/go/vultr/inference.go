// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vultr

import (
	"context"
	"reflect"

	"errors"
	"github.com/dirien/pulumi-vultr/sdk/v2/go/vultr/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Vultr Serverless Inference resource. This can be used to create, read, modify, and delete managed inference subscriptions on your Vultr account.
//
// ## Example Usage
//
// Create a new inference subscription:
//
// ```go
// package main
//
// import (
//
//	"github.com/dirien/pulumi-vultr/sdk/v2/go/vultr"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := vultr.NewInference(ctx, "myInferenceSubscription", &vultr.InferenceArgs{
//				Label: pulumi.String("my_inference_label"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Inference subscriptions can be imported using the subscription's `ID`, e.g.
//
// ```sh
// $ pulumi import vultr:index/inference:Inference my_inference_subscription b6a859c5-b299-49dd-8888-b1abbc517d08
// ```
type Inference struct {
	pulumi.CustomResourceState

	// The inference subscription's API key for accessing the Vultr Inference API.
	ApiKey pulumi.StringOutput `pulumi:"apiKey"`
	// The date the inference subscription was added to your Vultr account.
	DateCreated pulumi.StringOutput `pulumi:"dateCreated"`
	// A label for the inference subscription.
	Label pulumi.StringOutput `pulumi:"label"`
	Usage pulumi.MapOutput    `pulumi:"usage"`
}

// NewInference registers a new resource with the given unique name, arguments, and options.
func NewInference(ctx *pulumi.Context,
	name string, args *InferenceArgs, opts ...pulumi.ResourceOption) (*Inference, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Label == nil {
		return nil, errors.New("invalid value for required argument 'Label'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Inference
	err := ctx.RegisterResource("vultr:index/inference:Inference", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInference gets an existing Inference resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInference(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InferenceState, opts ...pulumi.ResourceOption) (*Inference, error) {
	var resource Inference
	err := ctx.ReadResource("vultr:index/inference:Inference", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Inference resources.
type inferenceState struct {
	// The inference subscription's API key for accessing the Vultr Inference API.
	ApiKey *string `pulumi:"apiKey"`
	// The date the inference subscription was added to your Vultr account.
	DateCreated *string `pulumi:"dateCreated"`
	// A label for the inference subscription.
	Label *string                `pulumi:"label"`
	Usage map[string]interface{} `pulumi:"usage"`
}

type InferenceState struct {
	// The inference subscription's API key for accessing the Vultr Inference API.
	ApiKey pulumi.StringPtrInput
	// The date the inference subscription was added to your Vultr account.
	DateCreated pulumi.StringPtrInput
	// A label for the inference subscription.
	Label pulumi.StringPtrInput
	Usage pulumi.MapInput
}

func (InferenceState) ElementType() reflect.Type {
	return reflect.TypeOf((*inferenceState)(nil)).Elem()
}

type inferenceArgs struct {
	// A label for the inference subscription.
	Label string `pulumi:"label"`
}

// The set of arguments for constructing a Inference resource.
type InferenceArgs struct {
	// A label for the inference subscription.
	Label pulumi.StringInput
}

func (InferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*inferenceArgs)(nil)).Elem()
}

type InferenceInput interface {
	pulumi.Input

	ToInferenceOutput() InferenceOutput
	ToInferenceOutputWithContext(ctx context.Context) InferenceOutput
}

func (*Inference) ElementType() reflect.Type {
	return reflect.TypeOf((**Inference)(nil)).Elem()
}

func (i *Inference) ToInferenceOutput() InferenceOutput {
	return i.ToInferenceOutputWithContext(context.Background())
}

func (i *Inference) ToInferenceOutputWithContext(ctx context.Context) InferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceOutput)
}

// InferenceArrayInput is an input type that accepts InferenceArray and InferenceArrayOutput values.
// You can construct a concrete instance of `InferenceArrayInput` via:
//
//	InferenceArray{ InferenceArgs{...} }
type InferenceArrayInput interface {
	pulumi.Input

	ToInferenceArrayOutput() InferenceArrayOutput
	ToInferenceArrayOutputWithContext(context.Context) InferenceArrayOutput
}

type InferenceArray []InferenceInput

func (InferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Inference)(nil)).Elem()
}

func (i InferenceArray) ToInferenceArrayOutput() InferenceArrayOutput {
	return i.ToInferenceArrayOutputWithContext(context.Background())
}

func (i InferenceArray) ToInferenceArrayOutputWithContext(ctx context.Context) InferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceArrayOutput)
}

// InferenceMapInput is an input type that accepts InferenceMap and InferenceMapOutput values.
// You can construct a concrete instance of `InferenceMapInput` via:
//
//	InferenceMap{ "key": InferenceArgs{...} }
type InferenceMapInput interface {
	pulumi.Input

	ToInferenceMapOutput() InferenceMapOutput
	ToInferenceMapOutputWithContext(context.Context) InferenceMapOutput
}

type InferenceMap map[string]InferenceInput

func (InferenceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Inference)(nil)).Elem()
}

func (i InferenceMap) ToInferenceMapOutput() InferenceMapOutput {
	return i.ToInferenceMapOutputWithContext(context.Background())
}

func (i InferenceMap) ToInferenceMapOutputWithContext(ctx context.Context) InferenceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InferenceMapOutput)
}

type InferenceOutput struct{ *pulumi.OutputState }

func (InferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Inference)(nil)).Elem()
}

func (o InferenceOutput) ToInferenceOutput() InferenceOutput {
	return o
}

func (o InferenceOutput) ToInferenceOutputWithContext(ctx context.Context) InferenceOutput {
	return o
}

// The inference subscription's API key for accessing the Vultr Inference API.
func (o InferenceOutput) ApiKey() pulumi.StringOutput {
	return o.ApplyT(func(v *Inference) pulumi.StringOutput { return v.ApiKey }).(pulumi.StringOutput)
}

// The date the inference subscription was added to your Vultr account.
func (o InferenceOutput) DateCreated() pulumi.StringOutput {
	return o.ApplyT(func(v *Inference) pulumi.StringOutput { return v.DateCreated }).(pulumi.StringOutput)
}

// A label for the inference subscription.
func (o InferenceOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v *Inference) pulumi.StringOutput { return v.Label }).(pulumi.StringOutput)
}

func (o InferenceOutput) Usage() pulumi.MapOutput {
	return o.ApplyT(func(v *Inference) pulumi.MapOutput { return v.Usage }).(pulumi.MapOutput)
}

type InferenceArrayOutput struct{ *pulumi.OutputState }

func (InferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Inference)(nil)).Elem()
}

func (o InferenceArrayOutput) ToInferenceArrayOutput() InferenceArrayOutput {
	return o
}

func (o InferenceArrayOutput) ToInferenceArrayOutputWithContext(ctx context.Context) InferenceArrayOutput {
	return o
}

func (o InferenceArrayOutput) Index(i pulumi.IntInput) InferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Inference {
		return vs[0].([]*Inference)[vs[1].(int)]
	}).(InferenceOutput)
}

type InferenceMapOutput struct{ *pulumi.OutputState }

func (InferenceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Inference)(nil)).Elem()
}

func (o InferenceMapOutput) ToInferenceMapOutput() InferenceMapOutput {
	return o
}

func (o InferenceMapOutput) ToInferenceMapOutputWithContext(ctx context.Context) InferenceMapOutput {
	return o
}

func (o InferenceMapOutput) MapIndex(k pulumi.StringInput) InferenceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Inference {
		return vs[0].(map[string]*Inference)[vs[1].(string)]
	}).(InferenceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InferenceInput)(nil)).Elem(), &Inference{})
	pulumi.RegisterInputType(reflect.TypeOf((*InferenceArrayInput)(nil)).Elem(), InferenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InferenceMapInput)(nil)).Elem(), InferenceMap{})
	pulumi.RegisterOutputType(InferenceOutput{})
	pulumi.RegisterOutputType(InferenceArrayOutput{})
	pulumi.RegisterOutputType(InferenceMapOutput{})
}
