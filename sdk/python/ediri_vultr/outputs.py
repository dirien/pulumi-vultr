# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DatabaseReadReplica',
    'InstanceBackupsSchedule',
    'KubernetesNodePools',
    'KubernetesNodePoolsNode',
    'LoadBalancerFirewallRule',
    'LoadBalancerForwardingRule',
    'LoadBalancerHealthCheck',
    'LoadBalancerSsl',
    'GetApplicationFilterResult',
    'GetBackupFilterResult',
    'GetBareMetalPlanFilterResult',
    'GetBareMetalServerFilterResult',
    'GetBlockStorageFilterResult',
    'GetDatabaseFilterResult',
    'GetDatabaseReadReplicaResult',
    'GetFirewallGroupFilterResult',
    'GetInstanceFilterResult',
    'GetInstanceIpv4FilterResult',
    'GetIsoPrivateFilterResult',
    'GetIsoPublicFilterResult',
    'GetKubernetesFilterResult',
    'GetKubernetesNodePoolResult',
    'GetKubernetesNodePoolNodeResult',
    'GetLoadBalancerFilterResult',
    'GetObjectStorageClusterFilterResult',
    'GetObjectStorageFilterResult',
    'GetOsFilterResult',
    'GetPlanFilterResult',
    'GetPrivateNetworkFilterResult',
    'GetRegionFilterResult',
    'GetReservedIpFilterResult',
    'GetReverseIpv4FilterResult',
    'GetReverseIpv6FilterResult',
    'GetSnapshotFilterResult',
    'GetSshKeyFilterResult',
    'GetStartupScriptFilterResult',
    'GetUserFilterResult',
    'GetVpc2FilterResult',
    'GetVpcFilterResult',
]

@pulumi.output_type
class DatabaseReadReplica(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterTimeZone":
            suggest = "cluster_time_zone"
        elif key == "databaseEngine":
            suggest = "database_engine"
        elif key == "databaseEngineVersion":
            suggest = "database_engine_version"
        elif key == "dateCreated":
            suggest = "date_created"
        elif key == "latestBackup":
            suggest = "latest_backup"
        elif key == "maintenanceDow":
            suggest = "maintenance_dow"
        elif key == "maintenanceTime":
            suggest = "maintenance_time"
        elif key == "mysqlLongQueryTime":
            suggest = "mysql_long_query_time"
        elif key == "mysqlRequirePrimaryKey":
            suggest = "mysql_require_primary_key"
        elif key == "mysqlSlowQueryLog":
            suggest = "mysql_slow_query_log"
        elif key == "mysqlSqlModes":
            suggest = "mysql_sql_modes"
        elif key == "planDisk":
            suggest = "plan_disk"
        elif key == "planRam":
            suggest = "plan_ram"
        elif key == "planReplicas":
            suggest = "plan_replicas"
        elif key == "planVcpus":
            suggest = "plan_vcpus"
        elif key == "redisEvictionPolicy":
            suggest = "redis_eviction_policy"
        elif key == "trustedIps":
            suggest = "trusted_ips"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseReadReplica. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseReadReplica.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseReadReplica.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 region: str,
                 cluster_time_zone: Optional[str] = None,
                 database_engine: Optional[str] = None,
                 database_engine_version: Optional[str] = None,
                 date_created: Optional[str] = None,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 id: Optional[str] = None,
                 latest_backup: Optional[str] = None,
                 maintenance_dow: Optional[str] = None,
                 maintenance_time: Optional[str] = None,
                 mysql_long_query_time: Optional[int] = None,
                 mysql_require_primary_key: Optional[bool] = None,
                 mysql_slow_query_log: Optional[bool] = None,
                 mysql_sql_modes: Optional[Sequence[str]] = None,
                 password: Optional[str] = None,
                 plan: Optional[str] = None,
                 plan_disk: Optional[int] = None,
                 plan_ram: Optional[int] = None,
                 plan_replicas: Optional[int] = None,
                 plan_vcpus: Optional[int] = None,
                 port: Optional[str] = None,
                 redis_eviction_policy: Optional[str] = None,
                 status: Optional[str] = None,
                 tag: Optional[str] = None,
                 trusted_ips: Optional[Sequence[str]] = None,
                 user: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param str label: A label for the managed database.
        :param str region: The ID of the region that the managed database is to be created in. [See List Regions](https://www.vultr.com/api/#operation/list-regions)
        :param str cluster_time_zone: The configured time zone for the Managed Database in TZ database format (e.g. `UTC`, `America/New_York`, `Europe/London`).
        :param str database_engine: The database engine of the new managed database.
        :param str database_engine_version: The database engine version of the new managed database.
        :param str date_created: The date the managed database was added to your Vultr account.
        :param str dbname: The managed database's default logical database.
        :param str host: The hostname assigned to the managed database.
        :param str id: The ID of the managed database.
        :param str latest_backup: The date of the latest backup available on the managed database.
        :param str maintenance_dow: The preferred maintenance day of week for the managed database.
        :param str maintenance_time: The preferred maintenance time for the managed database in 24-hour HH:00 format (e.g. `01:00`, `13:00`, `23:00`).
        :param int mysql_long_query_time: The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        :param bool mysql_require_primary_key: The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        :param bool mysql_slow_query_log: The configuration value for slow query logging on the managed database (MySQL engine types only).
        :param Sequence[str] mysql_sql_modes: A list of SQL modes to configure for the managed database (MySQL engine types only - `ALLOW_INVALID_DATES`, `ANSI`, `ANSI_QUOTES`, `ERROR_FOR_DIVISION_BY_ZERO`, `HIGH_NOT_PRECEDENCE`, `IGNORE_SPACE`, `NO_AUTO_VALUE_ON_ZERO`, `NO_DIR_IN_CREATE`, `NO_ENGINE_SUBSTITUTION`, `NO_UNSIGNED_SUBTRACTION`, `NO_ZERO_DATE`, `NO_ZERO_IN_DATE`, `ONLY_FULL_GROUP_BY`, `PIPES_AS_CONCAT`, `REAL_AS_FLOAT`, `STRICT_ALL_TABLES`, `STRICT_TRANS_TABLES`, `TIME_TRUNCATE_FRACTIONAL`, `TRADITIONAL`).
        :param str password: The password for the managed database's primary admin user.
        :param str plan: The ID of the plan that you want the managed database to subscribe to. [See List Managed Database Plans](https://www.vultr.com/api/#tag/managed-databases/operation/list-database-plans)
        :param int plan_disk: The description of the disk(s) on the managed database.
        :param int plan_ram: The amount of memory available on the managed database in MB.
        :param int plan_replicas: The number of standby nodes available on the managed database.
        :param int plan_vcpus: The number of virtual CPUs available on the managed database.
        :param str port: The connection port for the managed database.
        :param str redis_eviction_policy: The configuration value for the data eviction policy on the managed database (Redis engine types only - `noeviction`, `allkeys-lru`, `volatile-lru`, `allkeys-random`, `volatile-random`, `volatile-ttl`, `volatile-lfu`, `allkeys-lfu`).
        :param str status: The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        :param str tag: The tag to assign to the managed database.
        :param Sequence[str] trusted_ips: A list of allowed IP addresses for the managed database.
        :param str user: The primary admin user for the managed database.
        :param str vpc_id: The ID of the VPC Network to attach to the Managed Database.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "region", region)
        if cluster_time_zone is not None:
            pulumi.set(__self__, "cluster_time_zone", cluster_time_zone)
        if database_engine is not None:
            pulumi.set(__self__, "database_engine", database_engine)
        if database_engine_version is not None:
            pulumi.set(__self__, "database_engine_version", database_engine_version)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if latest_backup is not None:
            pulumi.set(__self__, "latest_backup", latest_backup)
        if maintenance_dow is not None:
            pulumi.set(__self__, "maintenance_dow", maintenance_dow)
        if maintenance_time is not None:
            pulumi.set(__self__, "maintenance_time", maintenance_time)
        if mysql_long_query_time is not None:
            pulumi.set(__self__, "mysql_long_query_time", mysql_long_query_time)
        if mysql_require_primary_key is not None:
            pulumi.set(__self__, "mysql_require_primary_key", mysql_require_primary_key)
        if mysql_slow_query_log is not None:
            pulumi.set(__self__, "mysql_slow_query_log", mysql_slow_query_log)
        if mysql_sql_modes is not None:
            pulumi.set(__self__, "mysql_sql_modes", mysql_sql_modes)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if plan_disk is not None:
            pulumi.set(__self__, "plan_disk", plan_disk)
        if plan_ram is not None:
            pulumi.set(__self__, "plan_ram", plan_ram)
        if plan_replicas is not None:
            pulumi.set(__self__, "plan_replicas", plan_replicas)
        if plan_vcpus is not None:
            pulumi.set(__self__, "plan_vcpus", plan_vcpus)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redis_eviction_policy is not None:
            pulumi.set(__self__, "redis_eviction_policy", redis_eviction_policy)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if trusted_ips is not None:
            pulumi.set(__self__, "trusted_ips", trusted_ips)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        A label for the managed database.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The ID of the region that the managed database is to be created in. [See List Regions](https://www.vultr.com/api/#operation/list-regions)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="clusterTimeZone")
    def cluster_time_zone(self) -> Optional[str]:
        """
        The configured time zone for the Managed Database in TZ database format (e.g. `UTC`, `America/New_York`, `Europe/London`).
        """
        return pulumi.get(self, "cluster_time_zone")

    @property
    @pulumi.getter(name="databaseEngine")
    def database_engine(self) -> Optional[str]:
        """
        The database engine of the new managed database.
        """
        return pulumi.get(self, "database_engine")

    @property
    @pulumi.getter(name="databaseEngineVersion")
    def database_engine_version(self) -> Optional[str]:
        """
        The database engine version of the new managed database.
        """
        return pulumi.get(self, "database_engine_version")

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[str]:
        """
        The date the managed database was added to your Vultr account.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        """
        The managed database's default logical database.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname assigned to the managed database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the managed database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="latestBackup")
    def latest_backup(self) -> Optional[str]:
        """
        The date of the latest backup available on the managed database.
        """
        return pulumi.get(self, "latest_backup")

    @property
    @pulumi.getter(name="maintenanceDow")
    def maintenance_dow(self) -> Optional[str]:
        """
        The preferred maintenance day of week for the managed database.
        """
        return pulumi.get(self, "maintenance_dow")

    @property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> Optional[str]:
        """
        The preferred maintenance time for the managed database in 24-hour HH:00 format (e.g. `01:00`, `13:00`, `23:00`).
        """
        return pulumi.get(self, "maintenance_time")

    @property
    @pulumi.getter(name="mysqlLongQueryTime")
    def mysql_long_query_time(self) -> Optional[int]:
        """
        The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_long_query_time")

    @property
    @pulumi.getter(name="mysqlRequirePrimaryKey")
    def mysql_require_primary_key(self) -> Optional[bool]:
        """
        The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_require_primary_key")

    @property
    @pulumi.getter(name="mysqlSlowQueryLog")
    def mysql_slow_query_log(self) -> Optional[bool]:
        """
        The configuration value for slow query logging on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_slow_query_log")

    @property
    @pulumi.getter(name="mysqlSqlModes")
    def mysql_sql_modes(self) -> Optional[Sequence[str]]:
        """
        A list of SQL modes to configure for the managed database (MySQL engine types only - `ALLOW_INVALID_DATES`, `ANSI`, `ANSI_QUOTES`, `ERROR_FOR_DIVISION_BY_ZERO`, `HIGH_NOT_PRECEDENCE`, `IGNORE_SPACE`, `NO_AUTO_VALUE_ON_ZERO`, `NO_DIR_IN_CREATE`, `NO_ENGINE_SUBSTITUTION`, `NO_UNSIGNED_SUBTRACTION`, `NO_ZERO_DATE`, `NO_ZERO_IN_DATE`, `ONLY_FULL_GROUP_BY`, `PIPES_AS_CONCAT`, `REAL_AS_FLOAT`, `STRICT_ALL_TABLES`, `STRICT_TRANS_TABLES`, `TIME_TRUNCATE_FRACTIONAL`, `TRADITIONAL`).
        """
        return pulumi.get(self, "mysql_sql_modes")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the managed database's primary admin user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def plan(self) -> Optional[str]:
        """
        The ID of the plan that you want the managed database to subscribe to. [See List Managed Database Plans](https://www.vultr.com/api/#tag/managed-databases/operation/list-database-plans)
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="planDisk")
    def plan_disk(self) -> Optional[int]:
        """
        The description of the disk(s) on the managed database.
        """
        return pulumi.get(self, "plan_disk")

    @property
    @pulumi.getter(name="planRam")
    def plan_ram(self) -> Optional[int]:
        """
        The amount of memory available on the managed database in MB.
        """
        return pulumi.get(self, "plan_ram")

    @property
    @pulumi.getter(name="planReplicas")
    def plan_replicas(self) -> Optional[int]:
        """
        The number of standby nodes available on the managed database.
        """
        return pulumi.get(self, "plan_replicas")

    @property
    @pulumi.getter(name="planVcpus")
    def plan_vcpus(self) -> Optional[int]:
        """
        The number of virtual CPUs available on the managed database.
        """
        return pulumi.get(self, "plan_vcpus")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        The connection port for the managed database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="redisEvictionPolicy")
    def redis_eviction_policy(self) -> Optional[str]:
        """
        The configuration value for the data eviction policy on the managed database (Redis engine types only - `noeviction`, `allkeys-lru`, `volatile-lru`, `allkeys-random`, `volatile-random`, `volatile-ttl`, `volatile-lfu`, `allkeys-lfu`).
        """
        return pulumi.get(self, "redis_eviction_policy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag to assign to the managed database.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="trustedIps")
    def trusted_ips(self) -> Optional[Sequence[str]]:
        """
        A list of allowed IP addresses for the managed database.
        """
        return pulumi.get(self, "trusted_ips")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        The primary admin user for the managed database.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC Network to attach to the Managed Database.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class InstanceBackupsSchedule(dict):
    def __init__(__self__, *,
                 type: str,
                 dom: Optional[int] = None,
                 dow: Optional[int] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of backup schedule Possible values are `daily`, `weekly`, `monthly`, `daily_alt_even`, or `daily_alt_odd`.
        :param int dom: Day of month to run. Use values between 1 and 28.
        :param int dow: Day of week to run. `1 = Sunday`, `2 = Monday`, `3 = Tuesday`, `4 = Wednesday`, `5 = Thursday`, `6 = Friday`, `7 = Saturday`
        :param int hour: Hour of day to run in UTC.
        """
        pulumi.set(__self__, "type", type)
        if dom is not None:
            pulumi.set(__self__, "dom", dom)
        if dow is not None:
            pulumi.set(__self__, "dow", dow)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of backup schedule Possible values are `daily`, `weekly`, `monthly`, `daily_alt_even`, or `daily_alt_odd`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def dom(self) -> Optional[int]:
        """
        Day of month to run. Use values between 1 and 28.
        """
        return pulumi.get(self, "dom")

    @property
    @pulumi.getter
    def dow(self) -> Optional[int]:
        """
        Day of week to run. `1 = Sunday`, `2 = Monday`, `3 = Tuesday`, `4 = Wednesday`, `5 = Thursday`, `6 = Friday`, `7 = Saturday`
        """
        return pulumi.get(self, "dow")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day to run in UTC.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class KubernetesNodePools(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeQuantity":
            suggest = "node_quantity"
        elif key == "autoScaler":
            suggest = "auto_scaler"
        elif key == "dateCreated":
            suggest = "date_created"
        elif key == "dateUpdated":
            suggest = "date_updated"
        elif key == "maxNodes":
            suggest = "max_nodes"
        elif key == "minNodes":
            suggest = "min_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePools. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePools.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePools.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 node_quantity: int,
                 plan: str,
                 auto_scaler: Optional[bool] = None,
                 date_created: Optional[str] = None,
                 date_updated: Optional[str] = None,
                 id: Optional[str] = None,
                 max_nodes: Optional[int] = None,
                 min_nodes: Optional[int] = None,
                 nodes: Optional[Sequence['outputs.KubernetesNodePoolsNode']] = None,
                 status: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str label: The label to be used as a prefix for nodes in this node pool.
        :param int node_quantity: The number of nodes in this node pool.
        :param str plan: The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
        :param bool auto_scaler: Enable the auto scaler for the default node pool.
        :param str date_created: Date node was created.
        :param str date_updated: Date of node pool updates.
        :param str id: ID of node.
        :param int max_nodes: The maximum number of nodes to use with the auto scaler.
        :param int min_nodes: The minimum number of nodes to use with the auto scaler.
        :param Sequence['KubernetesNodePoolsNodeArgs'] nodes: Array that contains information about nodes within this node pool.
        :param str status: Status of node.
        :param str tag: Tag for node pool.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "node_quantity", node_quantity)
        pulumi.set(__self__, "plan", plan)
        if auto_scaler is not None:
            pulumi.set(__self__, "auto_scaler", auto_scaler)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_updated is not None:
            pulumi.set(__self__, "date_updated", date_updated)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The label to be used as a prefix for nodes in this node pool.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="nodeQuantity")
    def node_quantity(self) -> int:
        """
        The number of nodes in this node pool.
        """
        return pulumi.get(self, "node_quantity")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="autoScaler")
    def auto_scaler(self) -> Optional[bool]:
        """
        Enable the auto scaler for the default node pool.
        """
        return pulumi.get(self, "auto_scaler")

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[str]:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter(name="dateUpdated")
    def date_updated(self) -> Optional[str]:
        """
        Date of node pool updates.
        """
        return pulumi.get(self, "date_updated")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[int]:
        """
        The maximum number of nodes to use with the auto scaler.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[int]:
        """
        The minimum number of nodes to use with the auto scaler.
        """
        return pulumi.get(self, "min_nodes")

    @property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.KubernetesNodePoolsNode']]:
        """
        Array that contains information about nodes within this node pool.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of node.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Tag for node pool.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class KubernetesNodePoolsNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateCreated":
            suggest = "date_created"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePoolsNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePoolsNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePoolsNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_created: Optional[str] = None,
                 id: Optional[str] = None,
                 label: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str date_created: Date node was created.
        :param str id: ID of node.
        :param str label: The label to be used as a prefix for nodes in this node pool.
        :param str status: Status of node.
        """
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[str]:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label to be used as a prefix for nodes in this node pool.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LoadBalancerFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_type: str,
                 port: int,
                 source: str,
                 id: Optional[str] = None):
        """
        :param str ip_type: The type of ip this rule is - may be either v4 or v6.
        :param int port: The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        :param str source: IP address with subnet that is allowed through the firewall. You may also pass in `cloudflare` which will allow only CloudFlares IP range.
        :param str id: The load balancer ID.
        """
        pulumi.set(__self__, "ip_type", ip_type)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "source", source)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> str:
        """
        The type of ip this rule is - may be either v4 or v6.
        """
        return pulumi.get(self, "ip_type")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        IP address with subnet that is allowed through the firewall. You may also pass in `cloudflare` which will allow only CloudFlares IP range.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The load balancer ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class LoadBalancerForwardingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPort":
            suggest = "backend_port"
        elif key == "backendProtocol":
            suggest = "backend_protocol"
        elif key == "frontendPort":
            suggest = "frontend_port"
        elif key == "frontendProtocol":
            suggest = "frontend_protocol"
        elif key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerForwardingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerForwardingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerForwardingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_port: int,
                 backend_protocol: str,
                 frontend_port: int,
                 frontend_protocol: str,
                 rule_id: Optional[str] = None):
        """
        :param int backend_port: Port on instance side.
        :param str backend_protocol: Protocol on instance side. Possible values: "http", "https", "tcp".
        :param int frontend_port: Port on load balancer side.
        :param str frontend_protocol: Protocol on load balancer side. Possible values: "http", "https", "tcp".
        """
        pulumi.set(__self__, "backend_port", backend_port)
        pulumi.set(__self__, "backend_protocol", backend_protocol)
        pulumi.set(__self__, "frontend_port", frontend_port)
        pulumi.set(__self__, "frontend_protocol", frontend_protocol)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> int:
        """
        Port on instance side.
        """
        return pulumi.get(self, "backend_port")

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> str:
        """
        Protocol on instance side. Possible values: "http", "https", "tcp".
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> int:
        """
        Port on load balancer side.
        """
        return pulumi.get(self, "frontend_port")

    @property
    @pulumi.getter(name="frontendProtocol")
    def frontend_protocol(self) -> str:
        """
        Protocol on load balancer side. Possible values: "http", "https", "tcp".
        """
        return pulumi.get(self, "frontend_protocol")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[str]:
        return pulumi.get(self, "rule_id")


@pulumi.output_type
class LoadBalancerHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkInterval":
            suggest = "check_interval"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "responseTimeout":
            suggest = "response_timeout"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 check_interval: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 path: Optional[str] = None,
                 response_timeout: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param int port: The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        :param str protocol: The protocol used to traffic requests to the load balancer. Possible values are `http`, or `tcp`. Default value is `http`.
        :param int check_interval: Time in seconds to perform health check. Default value is 15.
        :param int healthy_threshold: Number of failed attempts encountered before failover. Default value is 5.
        :param str path: The path on the attached instances that the load balancer should check against. Default value is `/`
        :param int response_timeout: Time in seconds to wait for a health check response. Default value is 5.
        :param int unhealthy_threshold: Number of failed attempts encountered before failover. Default value is 5.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if response_timeout is not None:
            pulumi.set(__self__, "response_timeout", response_timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used to traffic requests to the load balancer. Possible values are `http`, or `tcp`. Default value is `http`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[int]:
        """
        Time in seconds to perform health check. Default value is 15.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of failed attempts encountered before failover. Default value is 5.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path on the attached instances that the load balancer should check against. Default value is `/`
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="responseTimeout")
    def response_timeout(self) -> Optional[int]:
        """
        Time in seconds to wait for a health check response. Default value is 5.
        """
        return pulumi.get(self, "response_timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of failed attempts encountered before failover. Default value is 5.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class LoadBalancerSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: str,
                 private_key: str,
                 chain: Optional[str] = None):
        """
        :param str certificate: The SSL Certificate.
        :param str private_key: The SSL certificates private key.
        :param str chain: The SSL certificate chain.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "private_key", private_key)
        if chain is not None:
            pulumi.set(__self__, "chain", chain)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The SSL Certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The SSL certificates private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        """
        The SSL certificate chain.
        """
        return pulumi.get(self, "chain")


@pulumi.output_type
class GetApplicationFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBackupFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBareMetalPlanFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBareMetalServerFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBlockStorageFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDatabaseFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDatabaseReadReplicaResult(dict):
    def __init__(__self__, *,
                 cluster_time_zone: str,
                 database_engine: str,
                 database_engine_version: str,
                 date_created: str,
                 dbname: str,
                 host: str,
                 id: str,
                 label: str,
                 latest_backup: str,
                 maintenance_dow: str,
                 maintenance_time: str,
                 mysql_long_query_time: int,
                 mysql_require_primary_key: bool,
                 mysql_slow_query_log: bool,
                 mysql_sql_modes: Sequence[str],
                 password: str,
                 plan: str,
                 plan_disk: int,
                 plan_ram: int,
                 plan_replicas: int,
                 plan_vcpus: int,
                 port: str,
                 redis_eviction_policy: str,
                 region: str,
                 status: str,
                 tag: str,
                 trusted_ips: Sequence[str],
                 user: str,
                 vpc_id: str):
        """
        :param str cluster_time_zone: The configured time zone for the Managed Database in TZ database format.
        :param str database_engine: The database engine of the managed database.
        :param str database_engine_version: The database engine version of the managed database.
        :param str date_created: The date the managed database was added to your Vultr account.
        :param str dbname: The managed database's default logical database.
        :param str host: The hostname assigned to the managed database.
        :param str label: The managed database's label.
        :param str latest_backup: The date of the latest backup available on the managed database.
        :param str maintenance_dow: The preferred maintenance day of week for the managed database.
        :param str maintenance_time: The preferred maintenance time for the managed database.
        :param int mysql_long_query_time: The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        :param bool mysql_require_primary_key: The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        :param bool mysql_slow_query_log: The configuration value for slow query logging on the managed database (MySQL engine types only).
        :param Sequence[str] mysql_sql_modes: A list of SQL modes currently configured for the managed database (MySQL engine types only).
        :param str password: The password for the managed database's primary admin user.
        :param str plan: The managed database's plan ID.
        :param int plan_disk: The description of the disk(s) on the managed database.
        :param int plan_ram: The amount of memory available on the managed database in MB.
        :param int plan_replicas: The number of standby nodes available on the managed database.
        :param int plan_vcpus: The number of virtual CPUs available on the managed database.
        :param str port: The connection port for the managed database.
        :param str redis_eviction_policy: The configuration value for the data eviction policy on the managed database (Redis engine types only).
        :param str region: The region ID of the managed database.
        :param str status: The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        :param str tag: The managed database's tag.
        :param Sequence[str] trusted_ips: A list of allowed IP addresses for the managed database.
        :param str user: The primary admin user for the managed database.
        :param str vpc_id: The ID of the VPC Network attached to the Managed Database.
        """
        pulumi.set(__self__, "cluster_time_zone", cluster_time_zone)
        pulumi.set(__self__, "database_engine", database_engine)
        pulumi.set(__self__, "database_engine_version", database_engine_version)
        pulumi.set(__self__, "date_created", date_created)
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "latest_backup", latest_backup)
        pulumi.set(__self__, "maintenance_dow", maintenance_dow)
        pulumi.set(__self__, "maintenance_time", maintenance_time)
        pulumi.set(__self__, "mysql_long_query_time", mysql_long_query_time)
        pulumi.set(__self__, "mysql_require_primary_key", mysql_require_primary_key)
        pulumi.set(__self__, "mysql_slow_query_log", mysql_slow_query_log)
        pulumi.set(__self__, "mysql_sql_modes", mysql_sql_modes)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "plan_disk", plan_disk)
        pulumi.set(__self__, "plan_ram", plan_ram)
        pulumi.set(__self__, "plan_replicas", plan_replicas)
        pulumi.set(__self__, "plan_vcpus", plan_vcpus)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "redis_eviction_policy", redis_eviction_policy)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "trusted_ips", trusted_ips)
        pulumi.set(__self__, "user", user)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="clusterTimeZone")
    def cluster_time_zone(self) -> str:
        """
        The configured time zone for the Managed Database in TZ database format.
        """
        return pulumi.get(self, "cluster_time_zone")

    @property
    @pulumi.getter(name="databaseEngine")
    def database_engine(self) -> str:
        """
        The database engine of the managed database.
        """
        return pulumi.get(self, "database_engine")

    @property
    @pulumi.getter(name="databaseEngineVersion")
    def database_engine_version(self) -> str:
        """
        The database engine version of the managed database.
        """
        return pulumi.get(self, "database_engine_version")

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> str:
        """
        The date the managed database was added to your Vultr account.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The managed database's default logical database.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname assigned to the managed database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The managed database's label.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="latestBackup")
    def latest_backup(self) -> str:
        """
        The date of the latest backup available on the managed database.
        """
        return pulumi.get(self, "latest_backup")

    @property
    @pulumi.getter(name="maintenanceDow")
    def maintenance_dow(self) -> str:
        """
        The preferred maintenance day of week for the managed database.
        """
        return pulumi.get(self, "maintenance_dow")

    @property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> str:
        """
        The preferred maintenance time for the managed database.
        """
        return pulumi.get(self, "maintenance_time")

    @property
    @pulumi.getter(name="mysqlLongQueryTime")
    def mysql_long_query_time(self) -> int:
        """
        The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_long_query_time")

    @property
    @pulumi.getter(name="mysqlRequirePrimaryKey")
    def mysql_require_primary_key(self) -> bool:
        """
        The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_require_primary_key")

    @property
    @pulumi.getter(name="mysqlSlowQueryLog")
    def mysql_slow_query_log(self) -> bool:
        """
        The configuration value for slow query logging on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_slow_query_log")

    @property
    @pulumi.getter(name="mysqlSqlModes")
    def mysql_sql_modes(self) -> Sequence[str]:
        """
        A list of SQL modes currently configured for the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_sql_modes")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password for the managed database's primary admin user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        The managed database's plan ID.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="planDisk")
    def plan_disk(self) -> int:
        """
        The description of the disk(s) on the managed database.
        """
        return pulumi.get(self, "plan_disk")

    @property
    @pulumi.getter(name="planRam")
    def plan_ram(self) -> int:
        """
        The amount of memory available on the managed database in MB.
        """
        return pulumi.get(self, "plan_ram")

    @property
    @pulumi.getter(name="planReplicas")
    def plan_replicas(self) -> int:
        """
        The number of standby nodes available on the managed database.
        """
        return pulumi.get(self, "plan_replicas")

    @property
    @pulumi.getter(name="planVcpus")
    def plan_vcpus(self) -> int:
        """
        The number of virtual CPUs available on the managed database.
        """
        return pulumi.get(self, "plan_vcpus")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The connection port for the managed database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="redisEvictionPolicy")
    def redis_eviction_policy(self) -> str:
        """
        The configuration value for the data eviction policy on the managed database (Redis engine types only).
        """
        return pulumi.get(self, "redis_eviction_policy")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region ID of the managed database.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The managed database's tag.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="trustedIps")
    def trusted_ips(self) -> Sequence[str]:
        """
        A list of allowed IP addresses for the managed database.
        """
        return pulumi.get(self, "trusted_ips")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The primary admin user for the managed database.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of the VPC Network attached to the Managed Database.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetFirewallGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceIpv4FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values to filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values to filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetIsoPrivateFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetIsoPublicFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKubernetesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKubernetesNodePoolResult(dict):
    def __init__(__self__, *,
                 date_created: str,
                 date_updated: str,
                 id: str,
                 label: str,
                 node_quantity: int,
                 nodes: Sequence['outputs.GetKubernetesNodePoolNodeResult'],
                 plan: str,
                 status: str,
                 tag: str,
                 auto_scaler: Optional[bool] = None,
                 max_nodes: Optional[int] = None,
                 min_nodes: Optional[int] = None):
        """
        :param str date_created: Date node was created.
        :param str date_updated: Date of node pool updates.
        :param str id: ID of node.
        :param str label: Label of node.
        :param int node_quantity: Number of nodes within node pool.
        :param Sequence['GetKubernetesNodePoolNodeArgs'] nodes: Array that contains information about nodes within this node pool.
        :param str plan: Node plan that nodes are using within this node pool.
        :param str status: Status of node.
        :param str tag: Tag for node pool.
        :param bool auto_scaler: Boolean indicating if the auto scaler for the default node pool is active.
        :param int max_nodes: The maximum number of nodes used by the auto scaler.
        :param int min_nodes: The minimum number of nodes used by the auto scaler.
        """
        pulumi.set(__self__, "date_created", date_created)
        pulumi.set(__self__, "date_updated", date_updated)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "node_quantity", node_quantity)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tag", tag)
        if auto_scaler is not None:
            pulumi.set(__self__, "auto_scaler", auto_scaler)
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> str:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter(name="dateUpdated")
    def date_updated(self) -> str:
        """
        Date of node pool updates.
        """
        return pulumi.get(self, "date_updated")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label of node.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="nodeQuantity")
    def node_quantity(self) -> int:
        """
        Number of nodes within node pool.
        """
        return pulumi.get(self, "node_quantity")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetKubernetesNodePoolNodeResult']:
        """
        Array that contains information about nodes within this node pool.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Node plan that nodes are using within this node pool.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of node.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Tag for node pool.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="autoScaler")
    def auto_scaler(self) -> Optional[bool]:
        """
        Boolean indicating if the auto scaler for the default node pool is active.
        """
        return pulumi.get(self, "auto_scaler")

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[int]:
        """
        The maximum number of nodes used by the auto scaler.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[int]:
        """
        The minimum number of nodes used by the auto scaler.
        """
        return pulumi.get(self, "min_nodes")


@pulumi.output_type
class GetKubernetesNodePoolNodeResult(dict):
    def __init__(__self__, *,
                 date_created: str,
                 id: str,
                 label: str,
                 status: str):
        """
        :param str date_created: Date node was created.
        :param str id: ID of node.
        :param str label: Label of node.
        :param str status: Status of node.
        """
        pulumi.set(__self__, "date_created", date_created)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> str:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label of node.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLoadBalancerFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetObjectStorageClusterFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetObjectStorageFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetOsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPlanFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPrivateNetworkFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRegionFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetReservedIpFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetReverseIpv4FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values to filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values to filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetReverseIpv6FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values to filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values to filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSnapshotFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSshKeyFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetStartupScriptFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetUserFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpc2FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


