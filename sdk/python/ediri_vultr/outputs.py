# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DatabaseReadReplica',
    'InstanceBackupsSchedule',
    'KubernetesNodePools',
    'KubernetesNodePoolsNode',
    'LoadBalancerFirewallRule',
    'LoadBalancerForwardingRule',
    'LoadBalancerHealthCheck',
    'LoadBalancerSsl',
    'GetApplicationFilterResult',
    'GetBackupFilterResult',
    'GetBareMetalPlanFilterResult',
    'GetBareMetalServerFilterResult',
    'GetBlockStorageFilterResult',
    'GetDatabaseFilterResult',
    'GetDatabaseReadReplicaResult',
    'GetFirewallGroupFilterResult',
    'GetInstanceFilterResult',
    'GetInstanceIpv4FilterResult',
    'GetIsoPrivateFilterResult',
    'GetIsoPublicFilterResult',
    'GetKubernetesFilterResult',
    'GetKubernetesNodePoolResult',
    'GetKubernetesNodePoolNodeResult',
    'GetLoadBalancerFilterResult',
    'GetObjectStorageClusterFilterResult',
    'GetObjectStorageFilterResult',
    'GetOsFilterResult',
    'GetPlanFilterResult',
    'GetPrivateNetworkFilterResult',
    'GetRegionFilterResult',
    'GetReservedIpFilterResult',
    'GetReverseIpv4FilterResult',
    'GetReverseIpv6FilterResult',
    'GetSnapshotFilterResult',
    'GetSshKeyFilterResult',
    'GetStartupScriptFilterResult',
    'GetUserFilterResult',
    'GetVpc2FilterResult',
    'GetVpcFilterResult',
]

@pulumi.output_type
class DatabaseReadReplica(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterTimeZone":
            suggest = "cluster_time_zone"
        elif key == "databaseEngine":
            suggest = "database_engine"
        elif key == "databaseEngineVersion":
            suggest = "database_engine_version"
        elif key == "dateCreated":
            suggest = "date_created"
        elif key == "latestBackup":
            suggest = "latest_backup"
        elif key == "maintenanceDow":
            suggest = "maintenance_dow"
        elif key == "maintenanceTime":
            suggest = "maintenance_time"
        elif key == "mysqlLongQueryTime":
            suggest = "mysql_long_query_time"
        elif key == "mysqlRequirePrimaryKey":
            suggest = "mysql_require_primary_key"
        elif key == "mysqlSlowQueryLog":
            suggest = "mysql_slow_query_log"
        elif key == "mysqlSqlModes":
            suggest = "mysql_sql_modes"
        elif key == "planDisk":
            suggest = "plan_disk"
        elif key == "planRam":
            suggest = "plan_ram"
        elif key == "planReplicas":
            suggest = "plan_replicas"
        elif key == "planVcpus":
            suggest = "plan_vcpus"
        elif key == "redisEvictionPolicy":
            suggest = "redis_eviction_policy"
        elif key == "trustedIps":
            suggest = "trusted_ips"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseReadReplica. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseReadReplica.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseReadReplica.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 region: str,
                 cluster_time_zone: Optional[str] = None,
                 database_engine: Optional[str] = None,
                 database_engine_version: Optional[str] = None,
                 date_created: Optional[str] = None,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 id: Optional[str] = None,
                 latest_backup: Optional[str] = None,
                 maintenance_dow: Optional[str] = None,
                 maintenance_time: Optional[str] = None,
                 mysql_long_query_time: Optional[int] = None,
                 mysql_require_primary_key: Optional[bool] = None,
                 mysql_slow_query_log: Optional[bool] = None,
                 mysql_sql_modes: Optional[Sequence[str]] = None,
                 password: Optional[str] = None,
                 plan: Optional[str] = None,
                 plan_disk: Optional[int] = None,
                 plan_ram: Optional[int] = None,
                 plan_replicas: Optional[int] = None,
                 plan_vcpus: Optional[int] = None,
                 port: Optional[str] = None,
                 redis_eviction_policy: Optional[str] = None,
                 status: Optional[str] = None,
                 tag: Optional[str] = None,
                 trusted_ips: Optional[Sequence[str]] = None,
                 user: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        :param str label: A label for the managed database.
        :param str region: The ID of the region that the managed database is to be created in. [See List Regions](https://www.vultr.com/api/#operation/list-regions)
        :param str cluster_time_zone: The configured time zone for the Managed Database in TZ database format (e.g. `UTC`, `America/New_York`, `Europe/London`).
        :param str database_engine: The database engine of the new managed database.
        :param str database_engine_version: The database engine version of the new managed database.
        :param str date_created: The date the managed database was added to your Vultr account.
        :param str dbname: The managed database's default logical database.
        :param str host: The hostname assigned to the managed database.
        :param str id: The ID of the managed database.
        :param str latest_backup: The date of the latest backup available on the managed database.
        :param str maintenance_dow: The preferred maintenance day of week for the managed database.
        :param str maintenance_time: The preferred maintenance time for the managed database in 24-hour HH:00 format (e.g. `01:00`, `13:00`, `23:00`).
        :param int mysql_long_query_time: The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        :param bool mysql_require_primary_key: The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        :param bool mysql_slow_query_log: The configuration value for slow query logging on the managed database (MySQL engine types only).
        :param Sequence[str] mysql_sql_modes: A list of SQL modes to configure for the managed database (MySQL engine types only - `ALLOW_INVALID_DATES`, `ANSI`, `ANSI_QUOTES`, `ERROR_FOR_DIVISION_BY_ZERO`, `HIGH_NOT_PRECEDENCE`, `IGNORE_SPACE`, `NO_AUTO_VALUE_ON_ZERO`, `NO_DIR_IN_CREATE`, `NO_ENGINE_SUBSTITUTION`, `NO_UNSIGNED_SUBTRACTION`, `NO_ZERO_DATE`, `NO_ZERO_IN_DATE`, `ONLY_FULL_GROUP_BY`, `PIPES_AS_CONCAT`, `REAL_AS_FLOAT`, `STRICT_ALL_TABLES`, `STRICT_TRANS_TABLES`, `TIME_TRUNCATE_FRACTIONAL`, `TRADITIONAL`).
        :param str password: The password for the managed database's primary admin user.
        :param str plan: The ID of the plan that you want the managed database to subscribe to. [See List Managed Database Plans](https://www.vultr.com/api/#tag/managed-databases/operation/list-database-plans)
        :param int plan_disk: The description of the disk(s) on the managed database.
        :param int plan_ram: The amount of memory available on the managed database in MB.
        :param int plan_replicas: The number of standby nodes available on the managed database.
        :param int plan_vcpus: The number of virtual CPUs available on the managed database.
        :param str port: The connection port for the managed database.
        :param str redis_eviction_policy: The configuration value for the data eviction policy on the managed database (Redis engine types only - `noeviction`, `allkeys-lru`, `volatile-lru`, `allkeys-random`, `volatile-random`, `volatile-ttl`, `volatile-lfu`, `allkeys-lfu`).
        :param str status: The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        :param str tag: The tag to assign to the managed database.
        :param Sequence[str] trusted_ips: A list of allowed IP addresses for the managed database.
        :param str user: The primary admin user for the managed database.
        """
        DatabaseReadReplica._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            region=region,
            cluster_time_zone=cluster_time_zone,
            database_engine=database_engine,
            database_engine_version=database_engine_version,
            date_created=date_created,
            dbname=dbname,
            host=host,
            id=id,
            latest_backup=latest_backup,
            maintenance_dow=maintenance_dow,
            maintenance_time=maintenance_time,
            mysql_long_query_time=mysql_long_query_time,
            mysql_require_primary_key=mysql_require_primary_key,
            mysql_slow_query_log=mysql_slow_query_log,
            mysql_sql_modes=mysql_sql_modes,
            password=password,
            plan=plan,
            plan_disk=plan_disk,
            plan_ram=plan_ram,
            plan_replicas=plan_replicas,
            plan_vcpus=plan_vcpus,
            port=port,
            redis_eviction_policy=redis_eviction_policy,
            status=status,
            tag=tag,
            trusted_ips=trusted_ips,
            user=user,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: str,
             region: str,
             cluster_time_zone: Optional[str] = None,
             database_engine: Optional[str] = None,
             database_engine_version: Optional[str] = None,
             date_created: Optional[str] = None,
             dbname: Optional[str] = None,
             host: Optional[str] = None,
             id: Optional[str] = None,
             latest_backup: Optional[str] = None,
             maintenance_dow: Optional[str] = None,
             maintenance_time: Optional[str] = None,
             mysql_long_query_time: Optional[int] = None,
             mysql_require_primary_key: Optional[bool] = None,
             mysql_slow_query_log: Optional[bool] = None,
             mysql_sql_modes: Optional[Sequence[str]] = None,
             password: Optional[str] = None,
             plan: Optional[str] = None,
             plan_disk: Optional[int] = None,
             plan_ram: Optional[int] = None,
             plan_replicas: Optional[int] = None,
             plan_vcpus: Optional[int] = None,
             port: Optional[str] = None,
             redis_eviction_policy: Optional[str] = None,
             status: Optional[str] = None,
             tag: Optional[str] = None,
             trusted_ips: Optional[Sequence[str]] = None,
             user: Optional[str] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clusterTimeZone' in kwargs:
            cluster_time_zone = kwargs['clusterTimeZone']
        if 'databaseEngine' in kwargs:
            database_engine = kwargs['databaseEngine']
        if 'databaseEngineVersion' in kwargs:
            database_engine_version = kwargs['databaseEngineVersion']
        if 'dateCreated' in kwargs:
            date_created = kwargs['dateCreated']
        if 'latestBackup' in kwargs:
            latest_backup = kwargs['latestBackup']
        if 'maintenanceDow' in kwargs:
            maintenance_dow = kwargs['maintenanceDow']
        if 'maintenanceTime' in kwargs:
            maintenance_time = kwargs['maintenanceTime']
        if 'mysqlLongQueryTime' in kwargs:
            mysql_long_query_time = kwargs['mysqlLongQueryTime']
        if 'mysqlRequirePrimaryKey' in kwargs:
            mysql_require_primary_key = kwargs['mysqlRequirePrimaryKey']
        if 'mysqlSlowQueryLog' in kwargs:
            mysql_slow_query_log = kwargs['mysqlSlowQueryLog']
        if 'mysqlSqlModes' in kwargs:
            mysql_sql_modes = kwargs['mysqlSqlModes']
        if 'planDisk' in kwargs:
            plan_disk = kwargs['planDisk']
        if 'planRam' in kwargs:
            plan_ram = kwargs['planRam']
        if 'planReplicas' in kwargs:
            plan_replicas = kwargs['planReplicas']
        if 'planVcpus' in kwargs:
            plan_vcpus = kwargs['planVcpus']
        if 'redisEvictionPolicy' in kwargs:
            redis_eviction_policy = kwargs['redisEvictionPolicy']
        if 'trustedIps' in kwargs:
            trusted_ips = kwargs['trustedIps']
        if 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        _setter("label", label)
        _setter("region", region)
        if cluster_time_zone is not None:
            _setter("cluster_time_zone", cluster_time_zone)
        if database_engine is not None:
            _setter("database_engine", database_engine)
        if database_engine_version is not None:
            _setter("database_engine_version", database_engine_version)
        if date_created is not None:
            _setter("date_created", date_created)
        if dbname is not None:
            _setter("dbname", dbname)
        if host is not None:
            _setter("host", host)
        if id is not None:
            _setter("id", id)
        if latest_backup is not None:
            _setter("latest_backup", latest_backup)
        if maintenance_dow is not None:
            _setter("maintenance_dow", maintenance_dow)
        if maintenance_time is not None:
            _setter("maintenance_time", maintenance_time)
        if mysql_long_query_time is not None:
            _setter("mysql_long_query_time", mysql_long_query_time)
        if mysql_require_primary_key is not None:
            _setter("mysql_require_primary_key", mysql_require_primary_key)
        if mysql_slow_query_log is not None:
            _setter("mysql_slow_query_log", mysql_slow_query_log)
        if mysql_sql_modes is not None:
            _setter("mysql_sql_modes", mysql_sql_modes)
        if password is not None:
            _setter("password", password)
        if plan is not None:
            _setter("plan", plan)
        if plan_disk is not None:
            _setter("plan_disk", plan_disk)
        if plan_ram is not None:
            _setter("plan_ram", plan_ram)
        if plan_replicas is not None:
            _setter("plan_replicas", plan_replicas)
        if plan_vcpus is not None:
            _setter("plan_vcpus", plan_vcpus)
        if port is not None:
            _setter("port", port)
        if redis_eviction_policy is not None:
            _setter("redis_eviction_policy", redis_eviction_policy)
        if status is not None:
            _setter("status", status)
        if tag is not None:
            _setter("tag", tag)
        if trusted_ips is not None:
            _setter("trusted_ips", trusted_ips)
        if user is not None:
            _setter("user", user)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        A label for the managed database.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The ID of the region that the managed database is to be created in. [See List Regions](https://www.vultr.com/api/#operation/list-regions)
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="clusterTimeZone")
    def cluster_time_zone(self) -> Optional[str]:
        """
        The configured time zone for the Managed Database in TZ database format (e.g. `UTC`, `America/New_York`, `Europe/London`).
        """
        return pulumi.get(self, "cluster_time_zone")

    @property
    @pulumi.getter(name="databaseEngine")
    def database_engine(self) -> Optional[str]:
        """
        The database engine of the new managed database.
        """
        return pulumi.get(self, "database_engine")

    @property
    @pulumi.getter(name="databaseEngineVersion")
    def database_engine_version(self) -> Optional[str]:
        """
        The database engine version of the new managed database.
        """
        return pulumi.get(self, "database_engine_version")

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[str]:
        """
        The date the managed database was added to your Vultr account.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        """
        The managed database's default logical database.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname assigned to the managed database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the managed database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="latestBackup")
    def latest_backup(self) -> Optional[str]:
        """
        The date of the latest backup available on the managed database.
        """
        return pulumi.get(self, "latest_backup")

    @property
    @pulumi.getter(name="maintenanceDow")
    def maintenance_dow(self) -> Optional[str]:
        """
        The preferred maintenance day of week for the managed database.
        """
        return pulumi.get(self, "maintenance_dow")

    @property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> Optional[str]:
        """
        The preferred maintenance time for the managed database in 24-hour HH:00 format (e.g. `01:00`, `13:00`, `23:00`).
        """
        return pulumi.get(self, "maintenance_time")

    @property
    @pulumi.getter(name="mysqlLongQueryTime")
    def mysql_long_query_time(self) -> Optional[int]:
        """
        The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_long_query_time")

    @property
    @pulumi.getter(name="mysqlRequirePrimaryKey")
    def mysql_require_primary_key(self) -> Optional[bool]:
        """
        The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_require_primary_key")

    @property
    @pulumi.getter(name="mysqlSlowQueryLog")
    def mysql_slow_query_log(self) -> Optional[bool]:
        """
        The configuration value for slow query logging on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_slow_query_log")

    @property
    @pulumi.getter(name="mysqlSqlModes")
    def mysql_sql_modes(self) -> Optional[Sequence[str]]:
        """
        A list of SQL modes to configure for the managed database (MySQL engine types only - `ALLOW_INVALID_DATES`, `ANSI`, `ANSI_QUOTES`, `ERROR_FOR_DIVISION_BY_ZERO`, `HIGH_NOT_PRECEDENCE`, `IGNORE_SPACE`, `NO_AUTO_VALUE_ON_ZERO`, `NO_DIR_IN_CREATE`, `NO_ENGINE_SUBSTITUTION`, `NO_UNSIGNED_SUBTRACTION`, `NO_ZERO_DATE`, `NO_ZERO_IN_DATE`, `ONLY_FULL_GROUP_BY`, `PIPES_AS_CONCAT`, `REAL_AS_FLOAT`, `STRICT_ALL_TABLES`, `STRICT_TRANS_TABLES`, `TIME_TRUNCATE_FRACTIONAL`, `TRADITIONAL`).
        """
        return pulumi.get(self, "mysql_sql_modes")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the managed database's primary admin user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def plan(self) -> Optional[str]:
        """
        The ID of the plan that you want the managed database to subscribe to. [See List Managed Database Plans](https://www.vultr.com/api/#tag/managed-databases/operation/list-database-plans)
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="planDisk")
    def plan_disk(self) -> Optional[int]:
        """
        The description of the disk(s) on the managed database.
        """
        return pulumi.get(self, "plan_disk")

    @property
    @pulumi.getter(name="planRam")
    def plan_ram(self) -> Optional[int]:
        """
        The amount of memory available on the managed database in MB.
        """
        return pulumi.get(self, "plan_ram")

    @property
    @pulumi.getter(name="planReplicas")
    def plan_replicas(self) -> Optional[int]:
        """
        The number of standby nodes available on the managed database.
        """
        return pulumi.get(self, "plan_replicas")

    @property
    @pulumi.getter(name="planVcpus")
    def plan_vcpus(self) -> Optional[int]:
        """
        The number of virtual CPUs available on the managed database.
        """
        return pulumi.get(self, "plan_vcpus")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        The connection port for the managed database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="redisEvictionPolicy")
    def redis_eviction_policy(self) -> Optional[str]:
        """
        The configuration value for the data eviction policy on the managed database (Redis engine types only - `noeviction`, `allkeys-lru`, `volatile-lru`, `allkeys-random`, `volatile-random`, `volatile-ttl`, `volatile-lfu`, `allkeys-lfu`).
        """
        return pulumi.get(self, "redis_eviction_policy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The tag to assign to the managed database.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="trustedIps")
    def trusted_ips(self) -> Optional[Sequence[str]]:
        """
        A list of allowed IP addresses for the managed database.
        """
        return pulumi.get(self, "trusted_ips")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        The primary admin user for the managed database.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class InstanceBackupsSchedule(dict):
    def __init__(__self__, *,
                 type: str,
                 dom: Optional[int] = None,
                 dow: Optional[int] = None,
                 hour: Optional[int] = None):
        """
        :param str type: Type of backup schedule Possible values are `daily`, `weekly`, `monthly`, `daily_alt_even`, or `daily_alt_odd`.
        :param int dom: Day of month to run. Use values between 1 and 28.
        :param int dow: Day of week to run. `1 = Sunday`, `2 = Monday`, `3 = Tuesday`, `4 = Wednesday`, `5 = Thursday`, `6 = Friday`, `7 = Saturday`
        :param int hour: Hour of day to run in UTC.
        """
        InstanceBackupsSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            dom=dom,
            dow=dow,
            hour=hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             dom: Optional[int] = None,
             dow: Optional[int] = None,
             hour: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        if dom is not None:
            _setter("dom", dom)
        if dow is not None:
            _setter("dow", dow)
        if hour is not None:
            _setter("hour", hour)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of backup schedule Possible values are `daily`, `weekly`, `monthly`, `daily_alt_even`, or `daily_alt_odd`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def dom(self) -> Optional[int]:
        """
        Day of month to run. Use values between 1 and 28.
        """
        return pulumi.get(self, "dom")

    @property
    @pulumi.getter
    def dow(self) -> Optional[int]:
        """
        Day of week to run. `1 = Sunday`, `2 = Monday`, `3 = Tuesday`, `4 = Wednesday`, `5 = Thursday`, `6 = Friday`, `7 = Saturday`
        """
        return pulumi.get(self, "dow")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Hour of day to run in UTC.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class KubernetesNodePools(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeQuantity":
            suggest = "node_quantity"
        elif key == "autoScaler":
            suggest = "auto_scaler"
        elif key == "dateCreated":
            suggest = "date_created"
        elif key == "dateUpdated":
            suggest = "date_updated"
        elif key == "maxNodes":
            suggest = "max_nodes"
        elif key == "minNodes":
            suggest = "min_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePools. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePools.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePools.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 node_quantity: int,
                 plan: str,
                 auto_scaler: Optional[bool] = None,
                 date_created: Optional[str] = None,
                 date_updated: Optional[str] = None,
                 id: Optional[str] = None,
                 max_nodes: Optional[int] = None,
                 min_nodes: Optional[int] = None,
                 nodes: Optional[Sequence['outputs.KubernetesNodePoolsNode']] = None,
                 status: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str label: The label to be used as a prefix for nodes in this node pool.
        :param int node_quantity: The number of nodes in this node pool.
        :param str plan: The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
        :param bool auto_scaler: Enable the auto scaler for the default node pool.
        :param str date_created: Date node was created.
        :param str date_updated: Date of node pool updates.
        :param str id: ID of node.
        :param int max_nodes: The maximum number of nodes to use with the auto scaler.
        :param int min_nodes: The minimum number of nodes to use with the auto scaler.
        :param Sequence['KubernetesNodePoolsNodeArgs'] nodes: Array that contains information about nodes within this node pool.
        :param str status: Status of node.
        :param str tag: Tag for node pool.
        """
        KubernetesNodePools._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            node_quantity=node_quantity,
            plan=plan,
            auto_scaler=auto_scaler,
            date_created=date_created,
            date_updated=date_updated,
            id=id,
            max_nodes=max_nodes,
            min_nodes=min_nodes,
            nodes=nodes,
            status=status,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: str,
             node_quantity: int,
             plan: str,
             auto_scaler: Optional[bool] = None,
             date_created: Optional[str] = None,
             date_updated: Optional[str] = None,
             id: Optional[str] = None,
             max_nodes: Optional[int] = None,
             min_nodes: Optional[int] = None,
             nodes: Optional[Sequence['outputs.KubernetesNodePoolsNode']] = None,
             status: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nodeQuantity' in kwargs:
            node_quantity = kwargs['nodeQuantity']
        if 'autoScaler' in kwargs:
            auto_scaler = kwargs['autoScaler']
        if 'dateCreated' in kwargs:
            date_created = kwargs['dateCreated']
        if 'dateUpdated' in kwargs:
            date_updated = kwargs['dateUpdated']
        if 'maxNodes' in kwargs:
            max_nodes = kwargs['maxNodes']
        if 'minNodes' in kwargs:
            min_nodes = kwargs['minNodes']

        _setter("label", label)
        _setter("node_quantity", node_quantity)
        _setter("plan", plan)
        if auto_scaler is not None:
            _setter("auto_scaler", auto_scaler)
        if date_created is not None:
            _setter("date_created", date_created)
        if date_updated is not None:
            _setter("date_updated", date_updated)
        if id is not None:
            _setter("id", id)
        if max_nodes is not None:
            _setter("max_nodes", max_nodes)
        if min_nodes is not None:
            _setter("min_nodes", min_nodes)
        if nodes is not None:
            _setter("nodes", nodes)
        if status is not None:
            _setter("status", status)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The label to be used as a prefix for nodes in this node pool.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="nodeQuantity")
    def node_quantity(self) -> int:
        """
        The number of nodes in this node pool.
        """
        return pulumi.get(self, "node_quantity")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        The plan to be used in this node pool. [See Plans List](https://www.vultr.com/api/#operation/list-plans) Note the minimum plan requirements must have at least 1 core and 2 gbs of memory.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="autoScaler")
    def auto_scaler(self) -> Optional[bool]:
        """
        Enable the auto scaler for the default node pool.
        """
        return pulumi.get(self, "auto_scaler")

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[str]:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter(name="dateUpdated")
    def date_updated(self) -> Optional[str]:
        """
        Date of node pool updates.
        """
        return pulumi.get(self, "date_updated")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[int]:
        """
        The maximum number of nodes to use with the auto scaler.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[int]:
        """
        The minimum number of nodes to use with the auto scaler.
        """
        return pulumi.get(self, "min_nodes")

    @property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.KubernetesNodePoolsNode']]:
        """
        Array that contains information about nodes within this node pool.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of node.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Tag for node pool.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class KubernetesNodePoolsNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateCreated":
            suggest = "date_created"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePoolsNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePoolsNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePoolsNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_created: Optional[str] = None,
                 id: Optional[str] = None,
                 label: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str date_created: Date node was created.
        :param str id: ID of node.
        :param str label: The label to be used as a prefix for nodes in this node pool.
        :param str status: Status of node.
        """
        KubernetesNodePoolsNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_created=date_created,
            id=id,
            label=label,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_created: Optional[str] = None,
             id: Optional[str] = None,
             label: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dateCreated' in kwargs:
            date_created = kwargs['dateCreated']

        if date_created is not None:
            _setter("date_created", date_created)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[str]:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label to be used as a prefix for nodes in this node pool.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LoadBalancerFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_type: str,
                 port: int,
                 source: str,
                 id: Optional[str] = None):
        """
        :param str ip_type: The type of ip this rule is - may be either v4 or v6.
        :param int port: The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        :param str source: IP address with subnet that is allowed through the firewall. You may also pass in `cloudflare` which will allow only CloudFlares IP range.
        :param str id: The load balancer ID.
        """
        LoadBalancerFirewallRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_type=ip_type,
            port=port,
            source=source,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_type: str,
             port: int,
             source: str,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipType' in kwargs:
            ip_type = kwargs['ipType']

        _setter("ip_type", ip_type)
        _setter("port", port)
        _setter("source", source)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> str:
        """
        The type of ip this rule is - may be either v4 or v6.
        """
        return pulumi.get(self, "ip_type")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        IP address with subnet that is allowed through the firewall. You may also pass in `cloudflare` which will allow only CloudFlares IP range.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The load balancer ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class LoadBalancerForwardingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPort":
            suggest = "backend_port"
        elif key == "backendProtocol":
            suggest = "backend_protocol"
        elif key == "frontendPort":
            suggest = "frontend_port"
        elif key == "frontendProtocol":
            suggest = "frontend_protocol"
        elif key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerForwardingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerForwardingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerForwardingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_port: int,
                 backend_protocol: str,
                 frontend_port: int,
                 frontend_protocol: str,
                 rule_id: Optional[str] = None):
        """
        :param int backend_port: Port on instance side.
        :param str backend_protocol: Protocol on instance side. Possible values: "http", "https", "tcp".
        :param int frontend_port: Port on load balancer side.
        :param str frontend_protocol: Protocol on load balancer side. Possible values: "http", "https", "tcp".
        """
        LoadBalancerForwardingRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_port=backend_port,
            backend_protocol=backend_protocol,
            frontend_port=frontend_port,
            frontend_protocol=frontend_protocol,
            rule_id=rule_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_port: int,
             backend_protocol: str,
             frontend_port: int,
             frontend_protocol: str,
             rule_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'backendPort' in kwargs:
            backend_port = kwargs['backendPort']
        if 'backendProtocol' in kwargs:
            backend_protocol = kwargs['backendProtocol']
        if 'frontendPort' in kwargs:
            frontend_port = kwargs['frontendPort']
        if 'frontendProtocol' in kwargs:
            frontend_protocol = kwargs['frontendProtocol']
        if 'ruleId' in kwargs:
            rule_id = kwargs['ruleId']

        _setter("backend_port", backend_port)
        _setter("backend_protocol", backend_protocol)
        _setter("frontend_port", frontend_port)
        _setter("frontend_protocol", frontend_protocol)
        if rule_id is not None:
            _setter("rule_id", rule_id)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> int:
        """
        Port on instance side.
        """
        return pulumi.get(self, "backend_port")

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> str:
        """
        Protocol on instance side. Possible values: "http", "https", "tcp".
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> int:
        """
        Port on load balancer side.
        """
        return pulumi.get(self, "frontend_port")

    @property
    @pulumi.getter(name="frontendProtocol")
    def frontend_protocol(self) -> str:
        """
        Protocol on load balancer side. Possible values: "http", "https", "tcp".
        """
        return pulumi.get(self, "frontend_protocol")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[str]:
        return pulumi.get(self, "rule_id")


@pulumi.output_type
class LoadBalancerHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkInterval":
            suggest = "check_interval"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "responseTimeout":
            suggest = "response_timeout"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 protocol: str,
                 check_interval: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 path: Optional[str] = None,
                 response_timeout: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param int port: The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        :param str protocol: The protocol used to traffic requests to the load balancer. Possible values are `http`, or `tcp`. Default value is `http`.
        :param int check_interval: Time in seconds to perform health check. Default value is 15.
        :param int healthy_threshold: Number of failed attempts encountered before failover. Default value is 5.
        :param str path: The path on the attached instances that the load balancer should check against. Default value is `/`
        :param int response_timeout: Time in seconds to wait for a health check response. Default value is 5.
        :param int unhealthy_threshold: Number of failed attempts encountered before failover. Default value is 5.
        """
        LoadBalancerHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            protocol=protocol,
            check_interval=check_interval,
            healthy_threshold=healthy_threshold,
            path=path,
            response_timeout=response_timeout,
            unhealthy_threshold=unhealthy_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: int,
             protocol: str,
             check_interval: Optional[int] = None,
             healthy_threshold: Optional[int] = None,
             path: Optional[str] = None,
             response_timeout: Optional[int] = None,
             unhealthy_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'checkInterval' in kwargs:
            check_interval = kwargs['checkInterval']
        if 'healthyThreshold' in kwargs:
            healthy_threshold = kwargs['healthyThreshold']
        if 'responseTimeout' in kwargs:
            response_timeout = kwargs['responseTimeout']
        if 'unhealthyThreshold' in kwargs:
            unhealthy_threshold = kwargs['unhealthyThreshold']

        _setter("port", port)
        _setter("protocol", protocol)
        if check_interval is not None:
            _setter("check_interval", check_interval)
        if healthy_threshold is not None:
            _setter("healthy_threshold", healthy_threshold)
        if path is not None:
            _setter("path", path)
        if response_timeout is not None:
            _setter("response_timeout", response_timeout)
        if unhealthy_threshold is not None:
            _setter("unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The assigned port (integer) on the attached instances that the load balancer should check against. Default value is `80`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used to traffic requests to the load balancer. Possible values are `http`, or `tcp`. Default value is `http`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[int]:
        """
        Time in seconds to perform health check. Default value is 15.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of failed attempts encountered before failover. Default value is 5.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path on the attached instances that the load balancer should check against. Default value is `/`
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="responseTimeout")
    def response_timeout(self) -> Optional[int]:
        """
        Time in seconds to wait for a health check response. Default value is 5.
        """
        return pulumi.get(self, "response_timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of failed attempts encountered before failover. Default value is 5.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class LoadBalancerSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: str,
                 private_key: str,
                 chain: Optional[str] = None):
        """
        :param str certificate: The SSL Certificate.
        :param str private_key: The SSL certificates private key.
        :param str chain: The SSL certificate chain.
        """
        LoadBalancerSsl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            private_key=private_key,
            chain=chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: str,
             private_key: str,
             chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateKey' in kwargs:
            private_key = kwargs['privateKey']

        _setter("certificate", certificate)
        _setter("private_key", private_key)
        if chain is not None:
            _setter("chain", chain)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The SSL Certificate.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The SSL certificates private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        """
        The SSL certificate chain.
        """
        return pulumi.get(self, "chain")


@pulumi.output_type
class GetApplicationFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetApplicationFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBackupFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetBackupFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBareMetalPlanFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetBareMetalPlanFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBareMetalServerFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetBareMetalServerFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBlockStorageFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetBlockStorageFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDatabaseFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetDatabaseFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDatabaseReadReplicaResult(dict):
    def __init__(__self__, *,
                 cluster_time_zone: str,
                 database_engine: str,
                 database_engine_version: str,
                 date_created: str,
                 dbname: str,
                 host: str,
                 id: str,
                 label: str,
                 latest_backup: str,
                 maintenance_dow: str,
                 maintenance_time: str,
                 mysql_long_query_time: int,
                 mysql_require_primary_key: bool,
                 mysql_slow_query_log: bool,
                 mysql_sql_modes: Sequence[str],
                 password: str,
                 plan: str,
                 plan_disk: int,
                 plan_ram: int,
                 plan_replicas: int,
                 plan_vcpus: int,
                 port: str,
                 redis_eviction_policy: str,
                 region: str,
                 status: str,
                 tag: str,
                 trusted_ips: Sequence[str],
                 user: str,
                 vpc_id: str):
        """
        :param str cluster_time_zone: The configured time zone for the Managed Database in TZ database format.
        :param str database_engine: The database engine of the managed database.
        :param str database_engine_version: The database engine version of the managed database.
        :param str date_created: The date the managed database was added to your Vultr account.
        :param str dbname: The managed database's default logical database.
        :param str host: The hostname assigned to the managed database.
        :param str label: The managed database's label.
        :param str latest_backup: The date of the latest backup available on the managed database.
        :param str maintenance_dow: The preferred maintenance day of week for the managed database.
        :param str maintenance_time: The preferred maintenance time for the managed database.
        :param int mysql_long_query_time: The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        :param bool mysql_require_primary_key: The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        :param bool mysql_slow_query_log: The configuration value for slow query logging on the managed database (MySQL engine types only).
        :param Sequence[str] mysql_sql_modes: A list of SQL modes currently configured for the managed database (MySQL engine types only).
        :param str password: The password for the managed database's primary admin user.
        :param str plan: The managed database's plan ID.
        :param int plan_disk: The description of the disk(s) on the managed database.
        :param int plan_ram: The amount of memory available on the managed database in MB.
        :param int plan_replicas: The number of standby nodes available on the managed database.
        :param int plan_vcpus: The number of virtual CPUs available on the managed database.
        :param str port: The connection port for the managed database.
        :param str redis_eviction_policy: The configuration value for the data eviction policy on the managed database (Redis engine types only).
        :param str region: The region ID of the managed database.
        :param str status: The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        :param str tag: The managed database's tag.
        :param Sequence[str] trusted_ips: A list of allowed IP addresses for the managed database.
        :param str user: The primary admin user for the managed database.
        """
        GetDatabaseReadReplicaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_time_zone=cluster_time_zone,
            database_engine=database_engine,
            database_engine_version=database_engine_version,
            date_created=date_created,
            dbname=dbname,
            host=host,
            id=id,
            label=label,
            latest_backup=latest_backup,
            maintenance_dow=maintenance_dow,
            maintenance_time=maintenance_time,
            mysql_long_query_time=mysql_long_query_time,
            mysql_require_primary_key=mysql_require_primary_key,
            mysql_slow_query_log=mysql_slow_query_log,
            mysql_sql_modes=mysql_sql_modes,
            password=password,
            plan=plan,
            plan_disk=plan_disk,
            plan_ram=plan_ram,
            plan_replicas=plan_replicas,
            plan_vcpus=plan_vcpus,
            port=port,
            redis_eviction_policy=redis_eviction_policy,
            region=region,
            status=status,
            tag=tag,
            trusted_ips=trusted_ips,
            user=user,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_time_zone: str,
             database_engine: str,
             database_engine_version: str,
             date_created: str,
             dbname: str,
             host: str,
             id: str,
             label: str,
             latest_backup: str,
             maintenance_dow: str,
             maintenance_time: str,
             mysql_long_query_time: int,
             mysql_require_primary_key: bool,
             mysql_slow_query_log: bool,
             mysql_sql_modes: Sequence[str],
             password: str,
             plan: str,
             plan_disk: int,
             plan_ram: int,
             plan_replicas: int,
             plan_vcpus: int,
             port: str,
             redis_eviction_policy: str,
             region: str,
             status: str,
             tag: str,
             trusted_ips: Sequence[str],
             user: str,
             vpc_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clusterTimeZone' in kwargs:
            cluster_time_zone = kwargs['clusterTimeZone']
        if 'databaseEngine' in kwargs:
            database_engine = kwargs['databaseEngine']
        if 'databaseEngineVersion' in kwargs:
            database_engine_version = kwargs['databaseEngineVersion']
        if 'dateCreated' in kwargs:
            date_created = kwargs['dateCreated']
        if 'latestBackup' in kwargs:
            latest_backup = kwargs['latestBackup']
        if 'maintenanceDow' in kwargs:
            maintenance_dow = kwargs['maintenanceDow']
        if 'maintenanceTime' in kwargs:
            maintenance_time = kwargs['maintenanceTime']
        if 'mysqlLongQueryTime' in kwargs:
            mysql_long_query_time = kwargs['mysqlLongQueryTime']
        if 'mysqlRequirePrimaryKey' in kwargs:
            mysql_require_primary_key = kwargs['mysqlRequirePrimaryKey']
        if 'mysqlSlowQueryLog' in kwargs:
            mysql_slow_query_log = kwargs['mysqlSlowQueryLog']
        if 'mysqlSqlModes' in kwargs:
            mysql_sql_modes = kwargs['mysqlSqlModes']
        if 'planDisk' in kwargs:
            plan_disk = kwargs['planDisk']
        if 'planRam' in kwargs:
            plan_ram = kwargs['planRam']
        if 'planReplicas' in kwargs:
            plan_replicas = kwargs['planReplicas']
        if 'planVcpus' in kwargs:
            plan_vcpus = kwargs['planVcpus']
        if 'redisEvictionPolicy' in kwargs:
            redis_eviction_policy = kwargs['redisEvictionPolicy']
        if 'trustedIps' in kwargs:
            trusted_ips = kwargs['trustedIps']
        if 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        _setter("cluster_time_zone", cluster_time_zone)
        _setter("database_engine", database_engine)
        _setter("database_engine_version", database_engine_version)
        _setter("date_created", date_created)
        _setter("dbname", dbname)
        _setter("host", host)
        _setter("id", id)
        _setter("label", label)
        _setter("latest_backup", latest_backup)
        _setter("maintenance_dow", maintenance_dow)
        _setter("maintenance_time", maintenance_time)
        _setter("mysql_long_query_time", mysql_long_query_time)
        _setter("mysql_require_primary_key", mysql_require_primary_key)
        _setter("mysql_slow_query_log", mysql_slow_query_log)
        _setter("mysql_sql_modes", mysql_sql_modes)
        _setter("password", password)
        _setter("plan", plan)
        _setter("plan_disk", plan_disk)
        _setter("plan_ram", plan_ram)
        _setter("plan_replicas", plan_replicas)
        _setter("plan_vcpus", plan_vcpus)
        _setter("port", port)
        _setter("redis_eviction_policy", redis_eviction_policy)
        _setter("region", region)
        _setter("status", status)
        _setter("tag", tag)
        _setter("trusted_ips", trusted_ips)
        _setter("user", user)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="clusterTimeZone")
    def cluster_time_zone(self) -> str:
        """
        The configured time zone for the Managed Database in TZ database format.
        """
        return pulumi.get(self, "cluster_time_zone")

    @property
    @pulumi.getter(name="databaseEngine")
    def database_engine(self) -> str:
        """
        The database engine of the managed database.
        """
        return pulumi.get(self, "database_engine")

    @property
    @pulumi.getter(name="databaseEngineVersion")
    def database_engine_version(self) -> str:
        """
        The database engine version of the managed database.
        """
        return pulumi.get(self, "database_engine_version")

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> str:
        """
        The date the managed database was added to your Vultr account.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The managed database's default logical database.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname assigned to the managed database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The managed database's label.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="latestBackup")
    def latest_backup(self) -> str:
        """
        The date of the latest backup available on the managed database.
        """
        return pulumi.get(self, "latest_backup")

    @property
    @pulumi.getter(name="maintenanceDow")
    def maintenance_dow(self) -> str:
        """
        The preferred maintenance day of week for the managed database.
        """
        return pulumi.get(self, "maintenance_dow")

    @property
    @pulumi.getter(name="maintenanceTime")
    def maintenance_time(self) -> str:
        """
        The preferred maintenance time for the managed database.
        """
        return pulumi.get(self, "maintenance_time")

    @property
    @pulumi.getter(name="mysqlLongQueryTime")
    def mysql_long_query_time(self) -> int:
        """
        The configuration value for the long query time (in seconds) on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_long_query_time")

    @property
    @pulumi.getter(name="mysqlRequirePrimaryKey")
    def mysql_require_primary_key(self) -> bool:
        """
        The configuration value for whether primary keys are required on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_require_primary_key")

    @property
    @pulumi.getter(name="mysqlSlowQueryLog")
    def mysql_slow_query_log(self) -> bool:
        """
        The configuration value for slow query logging on the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_slow_query_log")

    @property
    @pulumi.getter(name="mysqlSqlModes")
    def mysql_sql_modes(self) -> Sequence[str]:
        """
        A list of SQL modes currently configured for the managed database (MySQL engine types only).
        """
        return pulumi.get(self, "mysql_sql_modes")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password for the managed database's primary admin user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        The managed database's plan ID.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter(name="planDisk")
    def plan_disk(self) -> int:
        """
        The description of the disk(s) on the managed database.
        """
        return pulumi.get(self, "plan_disk")

    @property
    @pulumi.getter(name="planRam")
    def plan_ram(self) -> int:
        """
        The amount of memory available on the managed database in MB.
        """
        return pulumi.get(self, "plan_ram")

    @property
    @pulumi.getter(name="planReplicas")
    def plan_replicas(self) -> int:
        """
        The number of standby nodes available on the managed database.
        """
        return pulumi.get(self, "plan_replicas")

    @property
    @pulumi.getter(name="planVcpus")
    def plan_vcpus(self) -> int:
        """
        The number of virtual CPUs available on the managed database.
        """
        return pulumi.get(self, "plan_vcpus")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The connection port for the managed database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="redisEvictionPolicy")
    def redis_eviction_policy(self) -> str:
        """
        The configuration value for the data eviction policy on the managed database (Redis engine types only).
        """
        return pulumi.get(self, "redis_eviction_policy")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The region ID of the managed database.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the managed database (poweroff, rebuilding, rebalancing, running).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The managed database's tag.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="trustedIps")
    def trusted_ips(self) -> Sequence[str]:
        """
        A list of allowed IP addresses for the managed database.
        """
        return pulumi.get(self, "trusted_ips")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The primary admin user for the managed database.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetFirewallGroupFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetFirewallGroupFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetInstanceFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceIpv4FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values to filter with.
        """
        GetInstanceIpv4FilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values to filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetIsoPrivateFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetIsoPrivateFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetIsoPublicFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetIsoPublicFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKubernetesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetKubernetesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetKubernetesNodePoolResult(dict):
    def __init__(__self__, *,
                 date_created: str,
                 date_updated: str,
                 id: str,
                 label: str,
                 node_quantity: int,
                 nodes: Sequence['outputs.GetKubernetesNodePoolNodeResult'],
                 plan: str,
                 status: str,
                 tag: str,
                 auto_scaler: Optional[bool] = None,
                 max_nodes: Optional[int] = None,
                 min_nodes: Optional[int] = None):
        """
        :param str date_created: Date node was created.
        :param str date_updated: Date of node pool updates.
        :param str id: ID of node.
        :param str label: Label of node.
        :param int node_quantity: Number of nodes within node pool.
        :param Sequence['GetKubernetesNodePoolNodeArgs'] nodes: Array that contains information about nodes within this node pool.
        :param str plan: Node plan that nodes are using within this node pool.
        :param str status: Status of node.
        :param str tag: Tag for node pool.
        :param bool auto_scaler: Boolean indicating if the auto scaler for the default node pool is active.
        :param int max_nodes: The maximum number of nodes used by the auto scaler.
        :param int min_nodes: The minimum number of nodes used by the auto scaler.
        """
        GetKubernetesNodePoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_created=date_created,
            date_updated=date_updated,
            id=id,
            label=label,
            node_quantity=node_quantity,
            nodes=nodes,
            plan=plan,
            status=status,
            tag=tag,
            auto_scaler=auto_scaler,
            max_nodes=max_nodes,
            min_nodes=min_nodes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_created: str,
             date_updated: str,
             id: str,
             label: str,
             node_quantity: int,
             nodes: Sequence['outputs.GetKubernetesNodePoolNodeResult'],
             plan: str,
             status: str,
             tag: str,
             auto_scaler: Optional[bool] = None,
             max_nodes: Optional[int] = None,
             min_nodes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dateCreated' in kwargs:
            date_created = kwargs['dateCreated']
        if 'dateUpdated' in kwargs:
            date_updated = kwargs['dateUpdated']
        if 'nodeQuantity' in kwargs:
            node_quantity = kwargs['nodeQuantity']
        if 'autoScaler' in kwargs:
            auto_scaler = kwargs['autoScaler']
        if 'maxNodes' in kwargs:
            max_nodes = kwargs['maxNodes']
        if 'minNodes' in kwargs:
            min_nodes = kwargs['minNodes']

        _setter("date_created", date_created)
        _setter("date_updated", date_updated)
        _setter("id", id)
        _setter("label", label)
        _setter("node_quantity", node_quantity)
        _setter("nodes", nodes)
        _setter("plan", plan)
        _setter("status", status)
        _setter("tag", tag)
        if auto_scaler is not None:
            _setter("auto_scaler", auto_scaler)
        if max_nodes is not None:
            _setter("max_nodes", max_nodes)
        if min_nodes is not None:
            _setter("min_nodes", min_nodes)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> str:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter(name="dateUpdated")
    def date_updated(self) -> str:
        """
        Date of node pool updates.
        """
        return pulumi.get(self, "date_updated")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label of node.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="nodeQuantity")
    def node_quantity(self) -> int:
        """
        Number of nodes within node pool.
        """
        return pulumi.get(self, "node_quantity")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetKubernetesNodePoolNodeResult']:
        """
        Array that contains information about nodes within this node pool.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Node plan that nodes are using within this node pool.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of node.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Tag for node pool.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="autoScaler")
    def auto_scaler(self) -> Optional[bool]:
        """
        Boolean indicating if the auto scaler for the default node pool is active.
        """
        return pulumi.get(self, "auto_scaler")

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[int]:
        """
        The maximum number of nodes used by the auto scaler.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[int]:
        """
        The minimum number of nodes used by the auto scaler.
        """
        return pulumi.get(self, "min_nodes")


@pulumi.output_type
class GetKubernetesNodePoolNodeResult(dict):
    def __init__(__self__, *,
                 date_created: str,
                 id: str,
                 label: str,
                 status: str):
        """
        :param str date_created: Date node was created.
        :param str id: ID of node.
        :param str label: Label of node.
        :param str status: Status of node.
        """
        GetKubernetesNodePoolNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_created=date_created,
            id=id,
            label=label,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_created: str,
             id: str,
             label: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dateCreated' in kwargs:
            date_created = kwargs['dateCreated']

        _setter("date_created", date_created)
        _setter("id", id)
        _setter("label", label)
        _setter("status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> str:
        """
        Date node was created.
        """
        return pulumi.get(self, "date_created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Label of node.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLoadBalancerFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetLoadBalancerFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetObjectStorageClusterFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetObjectStorageClusterFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetObjectStorageFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetObjectStorageFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetOsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetOsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPlanFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetPlanFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPrivateNetworkFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetPrivateNetworkFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRegionFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetRegionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetReservedIpFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetReservedIpFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetReverseIpv4FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values to filter with.
        """
        GetReverseIpv4FilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values to filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetReverseIpv6FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values to filter with.
        """
        GetReverseIpv6FilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values to filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSnapshotFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetSnapshotFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSshKeyFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetSshKeyFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetStartupScriptFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetStartupScriptFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetUserFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetUserFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpc2FilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetVpc2FilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVpcFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Attribute name to filter with.
        :param Sequence[str] values: One or more values filter with.
        """
        GetVpcFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Attribute name to filter with.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or more values filter with.
        """
        return pulumi.get(self, "values")


